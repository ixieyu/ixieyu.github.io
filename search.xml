<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DRF框架（三）]]></title>
    <url>%2Fposts%2Fb6a7d53b.html</url>
    <content type="text"><![CDATA[media资源路径设置 （设置好后把图片放在这个文件夹中，通过链接能访问到图片）1.先在根目录设置一个media文件夹 2.配置settings.py,加上下面的 12MEDIA_URL = &apos;/media/&apos;MEDIA_ROOT = os.path.join(BASE_DIR, &apos;media&apos;) 3.在urls.py路由设置 123456from django.views.static import servefrom django.conf import settingsurlpatterns = [ url(r&apos;^media/(?P&lt;path&gt;.*)&apos;, serve, &#123;&apos;document_root&apos;: settings.MEDIA_ROOT&#125;),] 多表设计12345678BaseModel基表 is_delete、create_time下面四表继承基表，可以继承两个字段Book表：name、price、img、authors、publish、is_delete、create_timePublish表：name、address、is_delete、create_time Author表：name、age、is_delete、create_timeAuthorDetail表：mobile, author、is_delete、create_time 基表设置 （注意设置abstract = True）1234567class BaseModel(models.Model): is_delete = models.BooleanField(default=False) create_time = models.DateTimeField(auto_now_add=True) # 设置 abstract = True 来声明基表，作为基表的Model不能在数据库中形成对应的表 class Meta: abstract = True 断关联多表关系 （\****）** db_constraint=False （设置了这个就是断关联，设置在外键，删除了作者详情，也不会删除作者）123456789101112131415161718192021222324252627282930313233343536373839401、外键位置： 一对多 - 外键放多的一方 一对一 - 从逻辑正反向考虑，如作者表与作者详情表，作者删除级联作者详情也删除，详情删除作者依旧存在，所以建议外键在详情表中 （和之前的一对一关系外键放置不一样，之前都是把外键放在查询频率高的表） 多对多 - 外键在关系表中 2、ORM正向方向连表查找： 正向：通过外键字段 eg: author_detial_obj.author #外键设置在作者详情表，在作者详情表中查询作者直接.author就可以 反向：通过设置反向查询related_name的值 eg：author_obj.detail #外键没有设置在作者表中，在作者表中通过设置反向查询.detail查询作者详情 注：依赖代码见下方 3、连表操作关系：（外键建在作者详情表中） 1）作者删除，详情级联 - on_delete=models.CASCADE #跟着一起删除 2）作者删除，详情置空 - null=True, on_delete=models.SET_NULL #外键字段清空 3）作者删除，详情重置 - default=0, on_delete=models.SET_DEFAULT 4）作者删除，详情不动 - on_delete=models.DO_NOTHING 注：拿作者与作者详情表举例 4、外键关联字段的参数 - 如何实现断关联、目前表间操作关系、方向查询字段 i）作者详情表中的（外键设置在作者详情表中） author = models.OneToOneField( to=&apos;Author&apos;, #和作者表关联 related_name=&apos;detail&apos;, #反查询，作者表直接查作者详情表的电话号码，可以直接author_obj.detail.mobile db_constraint=False, #断关联 on_delete=models.CASCADE #级联删除 ) ii）图书表中的 publish = models.ForeignKey( to=&apos;Publish&apos;, related_name=&apos;books&apos;, db_constraint=False, on_delete=models.DO_NOTHING, ) authors = models.ManyToManyField( to=&apos;Author&apos; related_name=&apos;books&apos;, db_constraint=False, ) 注：ManyToManyField不能设置on_delete，OneToOneField、ForeignKey必须设置on_delete（django1.x系统默认级联，但是django2.x必须手动明确） models.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from django.db import models#基类class BaseModel(models.Model): is_delete = models.BooleanField(default=False) #默认不是删除，数据库中是0/1 create_time = models.DateTimeField(auto_now_add=True) # 设置 abstract = True 来声明基表，作为基表的Model不能在数据库中形成对应的表 class Meta: abstract = True #声明该表只是一个抽象表不出现在数据库中#书籍表class Book(BaseModel): name = models.CharField(max_length=64) price = models.DecimalField(max_digits=5,decimal_places=2) img = models.ImageField(upload_to=&apos;img&apos;,default=&apos;default.jpg&apos;) #关联出版社表 publish = models.ForeignKey( to=&apos;Publish&apos;, #关联publish表 db_constraint=False, #断关联（断开Book表和Publish表的关联,方便删数据,虽然断开了关联但是还能正常使用） related_name=&apos;books&apos;,#反向查询字段：publish_obj.books就能查出当前出版社出版的的所有书籍 on_delete=models.DO_NOTHING,#设置连表操作关系 ) #关联作者表 authors = models.ManyToManyField( to=&apos;Author&apos;, db_constraint=True, #断开关联 related_name=&apos;books&apos; #反向查询字段 ) class Meta: db_table=&apos;book&apos; verbose_name=&apos;书籍&apos; verbose_name_plural=verbose_name def __str__(self): return self.name#出版社表class Publish(BaseModel): &quot;&quot;&quot;name、address、is_delete、create_time&quot;&quot;&quot; name = models.CharField(max_length=64) addres = models.CharField(max_length=64) class Meta: db_table=&apos;publish&apos; verbose_name=&apos;出版社&apos; verbose_name_plural=verbose_name def __str__(self): return self.name#作者表class Author(BaseModel): &quot;&quot;&quot;name、age、is_delete、create_time&quot;&quot;&quot; name = models.CharField(max_length=64) age = models.IntegerField() class Meta: db_table = &apos;author&apos; verbose_name=&apos;作者&apos; verbose_name_plural=verbose_name def __str__(self): return self.name#作者详情class AuthorDetail(BaseModel): &quot;&quot;&quot;mobile, author、is_delete、create_time&quot;&quot;&quot; mobile = models.CharField(max_length=11) author = models.OneToOneField( to=&apos;Author&apos;, db_constraint=False, related_name=&apos;detail&apos;, on_delete=models.CASCADE ) class Meta: db_table=&apos;author_detail&apos; verbose_name=&apos;作者详情&apos; verbose_name_plural=verbose_name def __str__(self): return self.author.name 序列化 ModelSerializer 模型类序列化器ModelSerializer与常规的Serializer相同，但提供了： 1.基于模型类自动生成一系列字段 2.包含默认的create()和update()的实现 3.基于模型类自动为Serializer生成validators,比如unique_together 序列化层：api/serializers.py 简单的写 123456789101112131415from rest_framework.serializers import ModelSerializer,SerializerMethodFieldfrom . import models#publish接口的序列化class PublishModelSerializers(ModelSerializer): class Me= (&apos;name&apos;,&apos;address&apos;) #选择需要序列化的字段，前端只显示这些字段（指明模型类的哪些字段生成）#Book接口序列化class BookModelSerializers(ModelSerializer): #了解：1.还可以自定义设置序列化字段，但是必须在fields中声明,在fields中写publish_address publish_address = SerializerMethodField() def get_publish_address(self,obj) return obj.publish.address #2.自定义连表深度-子序列化方式-该方式不能参与反序列化，使用在序列化和反序列化共存时，不能书写(******) publish = 在models.py中Book类设置publish_name和author_list属性方法 (插拔式获取) 12345678#序列化插拔式属性 -完成自定义字段名完成连表查询 @property def publish_name(self): #自定义查询出版社名字 return self.publish.name @property def author_list(self): return self.authors.values(&apos;name&apos;,&apos;age&apos;) 视图层 :views.py 123456789101112131415161718192021222324252627from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom . import models,serializersclass Book(APIView): def get(self,request,*args,**kwargs): pk = kwargs.get(&apos;pk&apos;) #单查 if pk: try: book_obj = models.Book.objects.filter(pk=pk,is_delete=False) book_data = serializers.BookModelSerializers(book_obj).data #单条数据序列化 except: return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;数据不存在&apos; &#125;) #群查 else: book_query = models.Book.objects.filter(is_delete=False).all() #先筛选查询,再查所有 book_data = serializers.BookModelSerializers(book_query,many=True).data #不管是一条还是多条，只要数据是被[]嵌套，都要写many=True #返回前端数据 return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:book_data &#125;) 路由层：api/urls.py 1234urlpatterns = [ url(r&apos;^books/$&apos;, views.Book.as_view()), url(r&apos;^books/(?P&lt;pk&gt;.*)/$&apos;, views.Book.as_view()),] 反序列化序列化层：api/serializers.py 123456789101112131415161718192021222324252627282930313233class BookModelDeserializer(ModelSerializer): #一些只参与反序列化的字段，但是不是与数据库关联的，自定义不入库的反序列化的字段 re_name = seializers.CharField(write_only=True) class Meta: model = models.Book fields = (&apos;name&apos;, &apos;price&apos;, &apos;publish&apos;, &apos;authors&apos;) #没有默认值的字段必须序列化，为其传值 # extra_kwargs 用来完成反序列化字段的 系统校验规则 extra_kwargs = &#123; &apos;name&apos;: &#123; &apos;required&apos;: True, #设置name字段必填 &apos;min_length&apos;: 1, &apos;error_messages&apos;: &#123; &apos;required&apos;: &apos;必填项&apos;, &apos;min_length&apos;: &apos;太短&apos;, &#125; &#125; &#125; # 局部钩子校验单个字段 validate_字段名 def validate_name(self, value): #value是字段name的值 # 书名不能包含 g 字符 if &apos;g&apos; in value.lower(): raise ValidationError(&apos;该g书不能出版&apos;) return value # 全局钩子 def validate(self, attrs): publish = attrs.get(&apos;publish&apos;) #publish如果是外键字段，这个就是publish对象 name = attrs.get(&apos;name&apos;) if models.Book.objects.filter(name=name, publish=publish): raise ValidationError(&#123;&apos;book&apos;: &apos;该书已存在&apos;&#125;) return attrs # 注意：ModelSerializer类已经帮我们实现了 create 与 update 方法,不需要写create就能创建 视图层：views.py 1234567891011def post(self,request,*args,**kwargs): request_data = request.data #获取post提交的数据包 book_ser = serializers.BookModelDeserializer(data=request_data) # raise_exception=True：当校验失败，马上终止当前视图方法，抛异常返回给前台 book_ser.is_valid(raise_exception=True) #检验是否合格 raise_exception=True必填的 book_obj = book_ser.save() #保存得到一个对象 return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:serializers.BookModelSerializers(book_obj).data &#125;) 路由层：urls.py 在postman中访问路径时最后必须带上/,post请求方式只有json格式能一个字段提交多个值,放在列表或者元组中，其余两个只能传递单个值 1234urlpatterns = [ url(r&apos;^books/$&apos;, views.Book.as_view()), url(r&apos;^books/(?P&lt;pk&gt;.*)/$&apos;, views.Book.as_view()),] 注意：（\****）** 1234567891011反序列化层：1.在设置fields，没有默认值的字段都必须设置反序列化保存到数据库中2.使用extra_kwargs 来设置系统校验规则3.设置局部钩子和全局钩子4.ModelSerializer类已经帮我们实现了 create 与 update 方法，不需要再写视图层：1.POST请求通过request.data拿到数据包2.传给反序列化 ,通过data=request_data传入需要反序列化的数据3.is_valid判断校验是否合格 ，raise_exception=True必须要写的4.通过.save()保存到数据库中 序列化与反序列化整合（**）序列化层：api/serializers.py 123456789101112131415161718192021222324252627282930313233343536373839404142class V2BookModelSerializer(ModelSerializer): class Meta: model = models.Book fields = (&apos;name&apos;, &apos;price&apos;, &apos;img&apos;, &apos;author_list&apos;, &apos;publish_name&apos;, &apos;publish&apos;, &apos;authors&apos;) extra_kwargs = &#123; &apos;name&apos;: &#123; &apos;required&apos;: True, &apos;min_length&apos;: 1, &apos;error_messages&apos;: &#123; &apos;required&apos;: &apos;必填项&apos;, &apos;min_length&apos;: &apos;太短&apos;, &#125; &#125;, &apos;publish&apos;: &#123; &apos;write_only&apos;: True &#125;, &apos;authors&apos;: &#123; &apos;write_only&apos;: True &#125;, &apos;img&apos;: &#123; &apos;read_only&apos;: True, &#125;, &apos;author_list&apos;: &#123; &apos;read_only&apos;: True, &#125;, &apos;publish_name&apos;: &#123; &apos;read_only&apos;: True, &#125; &#125; def validate_name(self, value): # 书名不能包含 g 字符 if &apos;g&apos; in value.lower(): raise ValidationError(&apos;该g书不能出版&apos;) return value def validate(self, attrs): publish = attrs.get(&apos;publish&apos;) name = attrs.get(&apos;name&apos;) if models.Book.objects.filter(name=name, publish=publish): raise ValidationError(&#123;&apos;book&apos;: &apos;该书已存在&apos;&#125;) return attrs 序列化层注意点： 12345671) fields中设置所有序列化与反序列化字段2) extra_kwargs划分只序列化或只反序列化字段（一般我们把需要存入到数据库中的使用write_only（反序列化）,只需要展示的就read_only(序列化)，看需求设计） write_only：只反序列化 read_only：只序列化 自定义字段默认只序列化(read_only) 如果字段没设置write_only或者read_only，那么该字段可以序列化和反序列化3) 设置反序列化所需的 系统、局部钩子、全局钩子 等校验规则 视图层：views.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class V2Book(APIView): def get(self,request,*args,**kwargs): pk = kwargs.get(&apos;pk&apos;) #单查 if pk: try: book_obj = models.Book.objects.get(pk=pk,is_delete=False) book_data = serializers.V2BookModelSerializer(book_obj).data #序列化 except: return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;参数有误&apos; &#125;) #群查 else: book_query=models.Book.objects.filter(is_delete=False).all() book_data = serializers.V2BookModelSerializer(book_query,many=True).data #序列化 return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:book_data &#125;) def post(self,request,*args,**kwargs): #单增:传的数据是与model对应的一个字典 # 群增：设计传递的是多个model对应的字典列表,在postman中通过列表嵌套字典传值 request_data = request.data if isinstance(request_data,dict): #判断获取的数据是否是dict many = False elif isinstance(request_data,list): #判断获取的数据是否是list many = True else: return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;数据错误&apos; &#125;) book_ser = serializers.V2BookModelSerializer(data=request_data,many=many) #反序列化 book_ser.is_valid(raise_exception=True) book_result = book_ser.save() #book_result是对象&lt;class &apos;app01.models.Book&apos;&gt;，群增就是列表套一个个对象 return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:serializers.V2BookModelSerializer(book_result,many=many).data &#125;) #单删: 有pk #在postman中通过路径传参 #群删：有pks &#123;&quot;pks&quot;: [1, 2, 3]&#125; #通过json传参 def delete(self,request,*args,**kwargs): pk = kwargs.get(&apos;pk&apos;) if pk: pks = [pk] else: pks = request.data.get(&apos;pks&apos;) if models.Book.objects.filter(pk__in=pks,is_delete=False).update(is_delete=True): return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;删除成功&apos; &#125;) return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;删除失败&apos; &#125;) 视图层注意点：(\**)** 1231.序列化数据最后必须要.data （因为要传给前端）2.反序列化通过data传参，序列化通过instance传参（当你只传一个参数时，默认是instanca的参数）3.反序列化与序列化都能使用many=True，序列化和反序列化数据只要被[]嵌套都要写many=True 路由层：urls.py 1234urlpatterns = [ url(r&apos;^v2/books/$&apos;, views.V2Book.as_view()), url(r&apos;^v2/books/(?P&lt;pk&gt;.*)/$&apos;, views.V2Book.as_view()),] instance/data/many/partial四个关键参数的用法总结 123456789101112instance/data/many/partial 影响序列化对象行为的四个关键参数。序列化情况：1.如果没有data参数，只有instance，那么就不存在反序列化校验一说，只有序列化对象instance。反序列化情况：2.如果有data，没有instance，那么需要进行校验data，然后将data进行反序列化，得到validated_data,此时再通过序列化对象获取data，这个data和初始化提供的data可不一样，这个序列化validated_data后的data，比起初始化data，可能减少了无效的字段（序列化没有定义的字段）。修改情况：3.如果又提供了instance 又提供了data, 那么只要有data或者部分data，那么data都要进行验证才能进行下面的save等操作，如果不经过is_valid过程，那么后面的获取序列化数据或者反序列化数据都会无效。ListSerializer使用情况：4.many参数将直接影响序列化类的类型，如果是many=False，那么直接使用当前序列化类。如果many=True,将实例化一个ListSerializer类来序列化或者反序列化类。（这也是看源码是漏掉的地方，一直奇怪普通Serialiszer类怎么没看到对多对象序列化的特殊处理。查看BaseSerializer.__new__方法）或者class Meta:中定义了list_serializer_class指定的多对象序列化类。修改情况要用instance指明要修改的对象：5.终于弄懂了，partial用于部分更新，为啥子要伴随instance,因为要指明给save用，在save操作时给那个instance部分更新。逻辑这回走到下面源码中的get_initial()获取要进行更新instance的字段数据。]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架（二）]]></title>
    <url>%2Fposts%2Fb6a7d53b.html</url>
    <content type="text"><![CDATA[解析模块为什么要配置解析模块 1231）drf给我们提供了多种解析数据包方式的解析类 form-data/urlencoded/json2）我们可以通过配置来控制前台提交的哪些格式的数据后台在解析，哪些数据不解析3）全局配置就是针对每一个视图类，局部配置就是针对指定的视图来，让它们可以按照配置规则选择性解析数据 源码入口 1234567891011# APIView类的dispatch方法中request = self.initialize_request(request, *args, **kwargs) # 点进去#准备要解析的数据parser_context=self.get_parser_context(request) #不是重点# 解析模块，获取解析类parsers=self.get_parsers() # 点进去# 去类属性(局部配置) 或 配置文件(全局配置) 拿 parser_classesreturn [parser() for parser in self.parser_classes] 解析模块源码：rest_framework/parsers.py 自定义全局配置：项目settings.py文件 12345678REST_FRAMEWORK = &#123; # 全局解析类配置 &apos;DEFAULT_PARSER_CLASSES&apos;: [ &apos;rest_framework.parsers.JSONParser&apos;, # json数据包 &apos;rest_framework.parsers.FormParser&apos;, # urlencoding数据包 &apos;rest_framework.parsers.MultiPartParser&apos; # form-date数据包 ],&#125; 自定义局部配置：应用views.py的具体视图类（设置了局部就不用设置全局） 12345from rest_framework.parsers import JSONParserclass Book(APIView): # 局部解析类配置，只要json类型的数据包才能被解析 parser_classes = [JSONParser] pass 代码示例 在局部设置只能解析json格式数据，在postman其他格式传递的数据都不显示 url拼接的参数，通过request.query_params获取参数。数据包传参通过request.data获取 123456789101112131415from . import modelsfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.parsers import JSONParser #用作解析类class Book(APIView): # 局部解析类配置,post提交数据只能解析json格式数据 parser_classes = [JSONParser] #如果[]为空，那么就相当于没有设置解析类型 def post(self, request, *args, **kwargs): # url拼接参数：只有一种传参方式就是拼接参数 print(request.query_params) # 数据包参数：有三种传参方式，form-data、urlencoding、json print(request.data) return Response(&apos;post ok&apos;) 异常模块 (走到逻辑异常都能被控制)为什么要自定义异常模块 12341）所有经过drf的APIView视图类产生的异常，都可以提供异常处理方案2）drf默认提供了异常处理方案(rest_framework.views.exception_handler)，但是处理范围有限3）drf提供的处理方案两种，处理了返回异常现象，没处理返回None(后续就是服务器抛异常给前台)4）自定义异常的目的就是解决drf没有处理的异常，让前台得到合理的异常信息返回，后台记录异常具体信息 源码分析 123456789101112# 异常模块：APIView类的dispatch方法中response = self.handle_exception(exc) # 点进去#自定义异常就是提供异常处理函数exception_handler,处理的目的就是让response一定有值#自定义：自己写exception_handler函数，在自己的配置文件配置EXCEPTION_HANDLER指向自己的处理异常函数exception_handler = self.get_exception_handler() #点进去 #获取处理异常的方法，也可以自定义异常处理方法，在settings文件中配置#settings中获取异常处理的方式return self.settings.EXCEPTION_HANDLER#异常处理的结果 # 自定义异常就是提供exception_handler异常处理函数，处理的目的就是让response一定有值response = exception_handler(exc, context) #最后发现在views中的exception_handler就是处理异常的方法 如何使用：自定义exception_handler函数如何书写实现体 12345# 修改自己的配置文件setting.pyREST_FRAMEWORK = &#123; # 全局配置异常模块 &apos;EXCEPTION_HANDLER&apos;: &apos;api.exception.exception_handler&apos;, #设置自定义异常文件路径，在api应用下创建exception文件，exception_handler函数&#125; api应用下创建处理异常文件exception.py 123456789101112131415161718191）先将异常处理交给rest_framework.views的exception_handler去处理 （******）2）判断处理的结果(返回值)response，有值代表drf已经处理了，None代表drf处理不了的异常，需要自定义去处理 （******）# 自定义异常处理文件exception，重写exception_handler函数from rest_framework.views import exception_handler as drf_exception_handler #drf原生处理异常函数取别名 drf_exception_handlerfrom rest_framework.views import Responsefrom rest_framework import statusdef exception_handler(exc, context): #自定义处理异常函数 # drf的exception_handler做基础处理 response = drf_exception_handler(exc, context) # 为空，就是drf框架处理不了的异常 if response is None: #处理之后为空，再进行自定义的二次处理 # print(exc) #错误原因 还可以做更详细的原因，通过判断exc信息类型 # print(context) #错误信息 print(&apos;%s - %s - %s&apos; % (context[&apos;view&apos;], context[&apos;request&apos;].method, exc)) return Response(&#123; &apos;detail&apos;: &apos;服务器错误&apos; &#125;, status=status.HTTP_500_INTERNAL_SERVER_ERROR, exception=True) return response #处理之后有值，就直接返回结果 异常模块的大致流程：从dispatch中的handle_exception进入，get_exception_handler()获得处理异常方法exception_handler()，在这里也可以自定义异常方法。执行exception_handler()获取异常处理的结果。 响应模块响应类构造器：rest_framework.response.Response 123456789101112def __init__(self, data=None, status=None, template_name=None, headers=None, exception=False, content_type=None): &quot;&quot;&quot; :param data: 响应数据 :param status: http响应状态码 :param template_name: drf也可以渲染页面，渲染的页面模板地址（不用了解） :param headers: 响应头 :param exception: 是否异常了 :param content_type: 响应的数据格式（一般不用处理，响应头中带了，且默认是json） &quot;&quot;&quot; pass 使用：常规实例化相应对象 1234# status就是解释一堆 数字 网络状态码的模块from rest_framework import status就是解释一堆 数字 网络状态码的模块# 一般情况下只需要返回数据，status和headers都有默认值return Response(data=&#123;数据&#125;, status=status.HTTP_200_OK, headers=&#123;设置的响应头&#125;) 序列化组件（下面都是讲关于Serializer）知识点：Serializer(偏底层)、ModelSerializer(重点)、ListModelSerializer(辅助群改) 为什么使用序列化组件：因为视图中查询到的对象和queryset类型不能直接作为数据返回给前台，所以要使用序列化组件（\****）** 1.定义Serializer类 模型层：models.py 12345678910111213141516171819class User(models.Model): SEX_CHOICES = [ [0,&apos;男&apos;], [1,&apos;女&apos;], ] name = models.CharField(max_length=64) pwd = models.CharField(max_length=32) phone = models.CharField(max_length=11,null=True,default=None) sex = models.IntegerField(choices=SEX_CHOICES,default=0) icon = models.ImageField(upload_to=&apos;icon&apos;,default=&apos;icon/default.jpg&apos;) class Meta: db_table=&apos;old_boy_user&apos; verbose_name=&apos;用户&apos; verbose_name_plural=verbose_name def __str__(self): return &apos;%s&apos; %self.name 自定义序列化类（自定义serializer类）： 1234567from rest_framework import serializersclass User(serializers.Serializer): id = serializers.IntergetField() #序列化括号里面不用加条件 name = serializer.CharField() . . . 配置层：settings.py 12345# 注册rest_frameworkINSTALLED_APPS = [ # ... &apos;rest_framework&apos;,] 2.分析源码创建Serializer对象中参数** 源码分析 BaseSerializer 1def __init__(self, instance=None, data=empty, **kwargs): 定义好Serialzier类后，就可以创建Serializer对象了。 Serializer的构造方法为： 1Serializer(instance=None,data=empty,**kwargs) 说明： 1.用于序列化时，将模型类对象传入instance参数 2.用于反序列化时，将要被反序列化的数据传入data参数 3.除了instance和data参数外，在构造Serializer对象时，还可以通过context参数额外添加数据 通过context参数附加的数据，可以通过Serializer对象的context属性获取 1serializer = AccountSerializer(account,context=&#123;&apos;request&apos;:request&#125;) 总结注意：**12345671.使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以2.序列化器无法直接接收数据，需要我们在视图中创建序列化器对象时把使用的数据传递过来。（data,instance传参）序列化是：数据对象从数据库中查出，通过instance传入序列化器中，必须通过data属性才能将序列化后的数据传给前端，不能直接传序列化对象反序列化是：数据是通过request.data从前端获取到数据，通过data传入序列化器中进行校验，保存到数据库中3.序列化器的字段声明类似于我们前面使用过的表单系统4.开发restful api时，序列化器会帮我们把模型数据转换成字典。5.drf提供的视图会帮我们把字典转换成json，或者把客户端发过来的数据转换成字典 3.序列化器的使用 序列化器的使用分两个阶段： 1.在客户端请求时：使用序列化器可以完成对数据的反序列化（就是前段往后端传递数据，反序列化之后保存数据） 2.在服务器响应时，使用序列化器可以完成对数据的序列化（服务器取出数据，序列化之后往前段发送展示） 序列化使用流程： 基本使用： 1.先查询出一个用户对象 12from models import useruser = User.object.get(id=2) 2.构造序列化器对象 12from user.serializers import UserSerializeruser_obj = Userserializer(user) #放入查询出的user对象 3.获取序列化对象 通过data属性可以获取序列化后的数据 12上面查出来的user_ser是一个serializer对象，需要取出具体的数据传给前端，所有要用到 user_ser.data取出具体数据user_ser = Userserializer(user).data 4.如果要被序列化的数据是包含多条数据的（也可以说被[ ]嵌套的，queryset类型数据，不管是多条还是单条）,需要添加many=True参数 12user = models.User.objects.all()user_ser = Userserialzier(user,many=True) 5.自定义序列化属性(重点\****) 下面有代码示例具体操作** 1serializers.SerializerMethodField() 反序列化使用流程： 数据验证： 1.使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。 2.在获取反序列化的数据前，必须调用is_valid()方法进行验证，验证成功返回True，否则返回False。 3.验证失败，可以通过序列化对象的errors属性获取错误信息，返回字典，包含了字段和字段的错误。 4.验证通过，可以通过序列化器对象的validated_data属性获取数据 保存数据： 序列化类中必须重写create方法用于新增，重写update方法是修改 视图中使用create()和save()方法 1从源码可知save()方法内部调用的是序列化类中的create方法，所以新增必须要在序列化类中重写create方法 4.代码示例序列化和反序列化在Serialzier组件中使用 序列化使用（展示给前台的数据） 序列化层：api/serializers.py (api应用下创建serializers.py文件) 121）设置需要返回给前台数据样式 那些model类有对应的字段，不需要返回的就不用设置了2）设置方法字段，字段名可以随意，字段值由 get_字段名 提供，来完成一些需要处理在返回的数据,类似于forms组件 1234567891011121314151617181920212223242526from rest_framework import serializers, exceptionsfrom django.conf import settingsfrom . import modelsclass UserSerializer(serializers.Serializer): #创建一个序列化类 name = serializers.CharField() phone = serializers.CharField() # 序列化提供给前台的字段个数由后台决定，可以少提供，但是提供的数据库对应的字段，名字一定要与数据库字段相同 # sex = serializers.IntegerField() # icon = serializers.ImageField() # 自定义序列化属性 # 属性名随意，值由固定的命名规范方法提供: # get_属性名(self, 参与序列化的model对象) # 返回值就是自定义序列化属性的值 gender = serializers.SerializerMethodField() def get_gender(self, obj): # choice类型的解释型值 get_字段_display() 来访问 return obj.get_sex_display() #自定义序列化属性icon icon = serializers.SerializerMethodField() def get_icon(self, obj): # settings.MEDIA_URL: 自己配置的 /media/，给后面高级序列化与视图类准备的 # obj.icon不能直接作为数据返回，因为内容虽然是字符串，但是类型是ImageFieldFile类型 return &apos;%s%s%s&apos; % (r&apos;http://127.0.0.1:8000&apos;, settings.MEDIA_URL, str(obj.icon)) 视图层 12345678910111213视图层书写的三个步骤1）从数据库中将要序列化给前台的model对象，或是多个model对象查询出来 user_obj = models.User.objects.get(pk=pk) 或者 user_obj_list = models.User.objects.all()2）将对象交给序列化处理，产生序列化对象，如果序列化的数据是由[]嵌套，一定要设置many=True user_ser = serializers.UserSerializer(user_obj) 或者 user_ser = serializers.UserSerializer(user_obj_list, many=True)3）序列化 对象.data 就是可以返回给前台的序列化数据 return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: 0, &apos;results&apos;: user_ser.data &#125;) 1234567891011121314151617181920212223242526272829class User(APIView): def get(self, request, *args, **kwargs): pk = kwargs.get(&apos;pk&apos;) if pk: #单查 try: # 用户对象不能直接作为数据返回给前台 user_obj = models.User.objects.get(pk=pk) # 序列化一下用户对象 user_ser = serializers.UserSerializer(user_obj) return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: 0, &apos;results&apos;: user_ser.data #如果你在序列化的时候没有.data,那么在传给前端的时候必须要.data &#125;) except: return Response(&#123; &apos;status&apos;: 2, &apos;msg&apos;: &apos;用户不存在&apos;, &#125;) else: #群查 # 用户对象列表(queryset)不能直接作为数据返回给前台 user_obj_list = models.User.objects.all() # 序列化一下用户对象 user_ser_data = serializers.UserSerializer(user_obj_list, many=True).data return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: 0, &apos;results&apos;: user_ser_data &#125;) 反序列化使用 （把数据存入数据库） 反序列层：api/serializers.py 12341）设置必填与选填序列化字段，设置校验规则2）为需要额外校验的字段提供局部钩子函数，如果该字段不入库，且不参与全局钩子校验，可以将值取出校验 pop3）为有联合关系的字段们提供全局钩子函数，如果某些字段不入库，可以将值取出校验4）必须重写create方法，完成校验通过的数据入库工作，得到新增的对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class UserDeserializer(serializers.Serializer): # 1) 哪些字段必须反序列化 # 2) 字段都有哪些安全校验 # 3) 哪些字段需要额外提供校验 钩子函数 # 4) 哪些字段间存在联合校验 # 注：反序列化字段都是用来入库的，不会出现自定义方法属性，会出现可以设置校验规则的自定义属性,不入数据库的 name = serializers.CharField( max_length=64, min_length=3, error_messages=&#123; &apos;max_length&apos;: &apos;太长&apos;, &apos;min_length&apos;: &apos;太短&apos; &#125; ) pwd = serializers.CharField() phone = serializers.CharField(required=False) sex = serializers.IntegerField(required=False) # 自定义有校验规则的反序列化字段,例如确认密码字段re_pwd re_pwd = serializers.CharField(required=True) # 小结： # name，pwd，re_pwd为必填字段 # phone，sex为选填字段 # 五个字段都必须提供完成的校验规则 # 局部钩子：validate_要校验的字段名(self, 当前要校验字段的值) # 校验规则：校验通过返回原值，校验失败，抛出异常 def validate_name(self, value): if &apos;g&apos; in value.lower(): # 名字中不能出现g raise exceptions.ValidationError(&apos;名字非法，是个鸡贼！&apos;) return value # 全局钩子：validate(self, 通过系统与局部钩子校验之后的所有数据) # 校验规则：校验通过返回原值，校验失败，抛出异常 def validate(self, attrs): #attrs是字典格式 pwd = attrs.get(&apos;pwd&apos;) re_pwd = attrs.pop(&apos;re_pwd&apos;) #因为re_pwd不需要入数据库，所以在全局钩子校验中删除掉这个字段 if pwd != re_pwd: raise exceptions.ValidationError(&#123;&apos;pwd&amp;re_pwd&apos;: &apos;两次密码不一致&apos;&#125;) return attrs # 要完成新增，必须自己重写 create 方法，validated_data是校验的数据 def create(self, validated_data): # 尽量在所有校验规则完毕之后，数据可以直接入库 return models.User.objects.create(**validated_data) 视图层:views.py 1234反序列化视图层三步：1）book_ser = serializers.UserDeserializer(data=request_data) # 反序列化数据必须赋值data,结果就是得到一个serializer对象2）book_ser.is_valid() # 把数据放到自定义serializer中校验，数据校验成功返回True,失败返回False3）不通过返回 book_ser.errors 给前台，通过 book_ser.save() 得到新增的对象，再正常返回 1234567891011121314151617181920212223242526272829class User(APIView): # 只考虑单增 def post(self, request, *args, **kwargs): # 请求数据 request_data = request.data # 数据是否合法（增加对象需要一个字典数据） if not isinstance(request_data, dict) or request_data == &#123;&#125;: return Response(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;数据有误&apos;, &#125;) # 数据类型合法，但数据内容不一定合法，需要校验数据，校验(参与反序列化)的数据需要赋值给data book_ser = serializers.UserDeserializer(data=request_data) # 序列化对象调用is_valid()完成校验，校验失败的失败信息都会被存储在 序列化对象.errors if book_ser.is_valid(): # 校验通过，完成新增 book_obj = book_ser.save() return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: &apos;ok&apos;, &apos;results&apos;: serializers.UserSerializer(book_obj).data &#125;) else: # 校验失败 return Response(&#123; &apos;status&apos;: 1, &apos;msg&apos;: book_ser.errors, &#125;)]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架（一）]]></title>
    <url>%2Fposts%2Ff97f4f6b.html</url>
    <content type="text"><![CDATA[搬运自:https://www.cnblogs.com/wangcuican/p/11748025.html 做备份 DRF框架全称：django-rest framework 知识点 123456接口：什么是接口、restful接口规范CBV生命周期源码 - 基于restful规范下的CBV接口请求组件、解析组件、响应组件序列化组件(灵魂)三大认证(重中之重)：认证、权限(权限六表)、频率其他组件：过滤、筛选、排序、分页、路由 接口123456接口：联系两个物质的媒介，完成信息交互web程序中：联系前台页面与后台数据库的媒介web接口组成： url：长得像返回数据的url链接 请求参数：前台按照指定的key提供数据给后台 响应数据：后台与数据库交互后将数据反馈给前台 restful接口规范12345接口规范：就是为了采用不同的后台语言，也能使用同样的接口获取到同样的数据如何写接口：接口规范是 规范化书写接口的，写接口要写 url、响应数据 注：如果将请求参数也纳入考量范围，那就是在写 接口文档 两大部分： url 12345678910111213141516171819201) 用api关键字标识接口url api.baidu.com | www.baidu.com/api 2) 接口数据安全性决定优先选择https协议3) 如果一个接口有多版本存在，需要在url中标识体现 api.baidu.com/v1/... | api.baidu.com/v2/... 4) 接口操作的数据源称之为 资源，在url中一般采用资源复数形式，一个接口可以概括对该资源的多种操作方式 api.baidu.com/books | api.baidu.com/books/(pk) 5) 请求方式有多种，用一个url处理如何保证不混乱 - 通过请求方式标识操作资源的方式 /books get 获取所有/获取一个 /books post 增加一个(多个) /books/(pk) delete 删除一个 params传参 /books/(pk) put 整体更新一个 /books/(pk) patch 局部更新一个6) 资源往往涉及数据的各种操作方式 - 筛选、排序、限制 api.baidu.com/books/?search=西&amp;ordering=-price&amp;limit=3 响应数据 就是下面的JsonResponse，返回给前端的数据 1234567891011121) http请求的响应会有响应状态码，接口用来返回操作的资源数据，可以拥有 操作数据结果的 状态码 status 0(操作资源成功) 1(操作资源失败) 2(操作资源成功，但没匹配结果) 注：资源状态码不像http状态码，一般都是后台与前台或是客户约定的 2) 资源的状态码文字提示 status ok &apos;账号有误&apos; &apos;密码有误&apos; &apos;用户锁定&apos; 3) 资源本身 results 注：删除资源成功不做任何数据返回(返回空字符串) 4) 不能直接放回的资源(子资源、图片、视频等资源)，返回该资源的url链接 基于restful规范的原生Django接口用规范的方法写django查询和增加范例 主路由 urls.py 1234567from django.conf.urls import url,includefrom django.contrib import adminurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^app01/&apos;, include(&apos;app01.urls&apos;)),] 应用app01下的urls.py 1234567from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r&apos;^books/$&apos;, views.Book.as_view()), url(r&apos;^books/(?P&lt;pk&gt;.*)/$&apos;, views.Book.as_view()),] 模型层 models.py 创建数据 12345678910111213from django.db import modelsclass Book(models.Model): title = models.CharField(max_length=64) price = models.DecimalField(max_digits=5,decimal_places=2) #生成五位数，小数两位 class Meta: db_table = &apos;old_boy_book&apos; #设置数据库名 verbose_name = &apos;书籍&apos; #设置中文名 verbose_name_plural = verbose_name #需要设置这个不然verbose_name会变成书籍s def __str__(self): return &apos;《%s》&apos; %self.title 后台层admin.py 创建登录admin页面 12345from django.contrib import adminfrom . import modelsadmin.site.register(models.Book) 创建超级用户 1&gt;: createsuperuser 数据库迁移 12&gt;: python manage.py makemigrations&gt;: python manage.py migrrate 视图层：views.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from django.http import JsonResponsefrom django.views import Viewfrom . import modelsclass Book(View): #查询 def get(self,request,*args,**kwargs): # print(args) #无名参数是元组 print(kwargs) #有名分组是字典 pk = kwargs.get(&apos;pk&apos;) if not pk: #群查 #操作数据库查询 book_obj_list = models.Book.objects.all() # print(book_obj_list) #序列化数据(把每条数据放在一个字典中，把所有字典数据放在一个list中,数据更好看) book_list = [] for obj in book_obj_list: dic = &#123;&#125; dic[&apos;title&apos;] = obj.title dic[&apos;price&apos;] = obj.price book_list.append(dic) #响应数据（后台返回给前台的数据） return JsonResponse(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:book_list &#125;,json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) #取消中文转义 else: #单查 book_dic = models.Book.objects.filter(pk=pk).filter().values(&apos;title&apos;,&apos;price&apos;).first() #如果不写first()，还是queryset对象 &lt;QuerySet [&#123;&apos;title&apos;: &apos;气球&apos;, &apos;price&apos;: Decimal(&apos;555.00&apos;)&#125;]&gt; # print(book_dic) # &#123;&apos;title&apos;: &apos;气球&apos;, &apos;price&apos;: Decimal(&apos;555.00&apos;)&#125; if book_dic: return JsonResponse(&#123; &apos;status&apos;: 0, &apos;msg&apos;: &apos;ok&apos;, &apos;results&apos;: book_dic &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) # 取消中文转义 #没有查询到数据 return JsonResponse(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;没有查询到结果&apos;, &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) # 取消中文转义 #增加 def post(self,request,*args,**kwargs): # print(request.POST.dict()) #&#123;&apos;title&apos;: &apos;西游记&apos;, &apos;price&apos;: &apos;4.55&apos;&#125; try: book_obj = models.Book.objects.create(**request.POST.dict()) #create增加数据 if book_obj: return JsonResponse(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:&#123;&apos;title&apos;:book_obj.title,&apos;price&apos;:book_obj.price&#125; &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) except: return JsonResponse(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;参数错误&apos;, &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) return JsonResponse(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;增加错误&apos;, &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) Postman接口工具 12345671.官网下载安装2.get请求，携带参数采用Params，传值3.post等请求，在Body里面加数据，提交数据包可以采用三种方式：form-date、urlencoding、json，原生的django对urlencoding方式数据兼容最好所有请求都可以携带请求头 原生Django CBV请求生命周期源码分析： 1https://www.cnblogs.com/wangcuican/p/11991750.html DRF框架安装 1&gt;: pip install djangorestframework drf框架规矩的封装风格 views.py 1234567891011121314from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.request import Requestfrom rest_framework.serializers import Serializerfrom rest_framework.settings import APISettingsfrom rest_framework.filters import SearchFilter #过滤from rest_framework.pagination import PageNumberPagination #分页from rest_framework.authentication import TokenAuthentication #认证from rest_framework.permissions import IsAuthenticated #权限（是否登录）from rest_framework.throttling import SimpleRateThrottle #频率class Test(APIView): def get(self, request, *args, **kwargs): return Response(&apos;drf get ok&apos;) drf请求生命周期流程（重点\****）** 1234567891) 根据应用中urls.py,走as_view方法，但是视图类没有该方法，所以请求走的是APIView的as_view方法2) 在APIView的as_view调用父类(django原生View)的as_view，同时还禁用了 csrf 认证3) 在父类（django原生View）的as_view中dispatch方法请求走的又是APIView的dispatch #因为APIView也可以走dispatch,视图类是先继承APIView,APIView中没有再去原生View中4) 完成任务方法交给视图类的请求函数处理，得到请求的响应结果，返回给前台所以以后直接就从APIView的dispatch入口看源码 请求模块：request对象源码入口 1APIView类的dispatch方法中：request = self.initialize_request(request, *args, **kwargs) 源码分析 1234567891011121314151617# 二次封装request (请求模块)request = self.initialize_request(request, *args, **kwargs) #点进去#点击查看Request源码return Request( request, ...)# 在rest_framework.request.Request实例化方法中self._request = request #将原生request作为drf request的_request属性# 在rest_framework.request.Request的__getattr__方法中try: return getattr(self._request, attr) # 访问属性完全兼容原生requestexcept AttributeError: return self.__getattribute__(attr) Request源码地址在:rest_framework/requests.py 重点总结 123451) drf 对原生request做了二次封装，设置request._request等于原生request2) 原生request对象的属性和方法都可以被drf的request对象直接访问(兼容)3) drf请求的所有url拼接参数均被解析到query_params中，所有数据包数据都被解析到data中 (******)get请求：url中拼接的参数通过request.query_params获取post请求：所有请求方式所携带的数据包都是通过request.data获取 请求模块最终的结论就是**：获取数据有两种方式 query_params和data（通过parser解析数据传到data）** 使用drf写的get/post请求 123456789101112131415161718class Test(APIView): def get(self, request, *args, **kwargs): # url拼接的参数 print(request._request.GET) # 二次封装方式 print(request.GET) # 兼容 print(request.query_params) # 拓展 return Response(&apos;drf get ok&apos;) def post(self, request, *args, **kwargs): # 所有请求方式携带的数据包 print(request._request.POST) # 二次封装方式 print(request.POST) # 兼容 print(request.data) # 拓展，兼容性最强，三种传参方式都可以：form-data,urlencoding,json print(request.query_params) return Response(&apos;drf post ok&apos;) 渲染模块：浏览器和Postman请求结果渲染数据的方式不一样 源码入口 1APIView类的dispatch方法中：self.response = self.finalize_response(request, response, *args, **kwargs) 源码分析 1234567891011121314# 最后解析reponse对象数据self.response = self.finalize_response(request, response, *args, **kwargs) #点进去# 拿到运行的解析类的对象们neg = self.perform_content_negotiation(request, force=True) #点进去# 获得解析类对象renderers = self.get_renderers() #点进去# 从视图类中得到renderer_classes请求类，如何实例化一个个对象形参解析类对象列表return [renderer() for renderer in self.renderer_classes] #配置文件重点：从self.renderer_classes获取renderer_classes，然后从api_settings中获取渲染模块的配置 1.自己视图类的类属性(局部配置) =&gt; 2.APIView类的类属性设置 =&gt; 3.自己配置文件的DEFAULT_RENDERER_CLASSES(全局配置) =&gt; 4.drf配置文件的DEFAULT_RENDERER_CLASSES 渲染模块源码地址：rest_framework/renderers.py 自定义全局配置：所有视图类统一处理，在项目的settings.py中（\****）** 1234567REST_FRAMEWORK = &#123; # drf提供的渲染类 &apos;DEFAULT_RENDERER_CLASSES&apos;: [ &apos;rest_framework.renderers.JSONRenderer&apos;, #只显示出json数据 &apos;rest_framework.renderers.BrowsableAPIRenderer&apos;, #渲染出页面，注意是BrowsableAPIRenderer ],&#125; 自定义局部配置：某一个或一些实体类单独处理，在views.py视图类中提供对应的类属性（\****）** 1234567891011# 在setting.py中配置REST_FRAMEWORK，完成的是全局配置，所有接口统一处理# 如果只有部分接口特殊化，可以完成 - 局部配置from rest_framework.renderers import JSONRendererclass Test2(APIView): # 局部配置 renderer_classes = [JSONRenderer] def get(self, request, *args, **kwargs): return Response(&apos;drf get ok 2&apos;) def post(self, request, *args, **kwargs): return Response(&apos;drf post ok 2&apos;)]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019总结]]></title>
    <url>%2Fposts%2Fac33bbfd.html</url>
    <content type="text"><![CDATA[2019总结：1.买一套200w的房子（已完成)2.买一辆特斯拉（已完成）3.存款200w（已完成）4.有一次说走就走的旅行（已完成）5.改掉吹牛逼的习惯（未完成）]]></content>
  </entry>
  <entry>
    <title><![CDATA[圣诞节]]></title>
    <url>%2Fposts%2Fa810acad.html</url>
    <content type="text"><![CDATA[圣诞节快乐啊！ 圣诞节下雨了！睡个好觉~ 晚安ps：偃师]]></content>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取电子书]]></title>
    <url>%2Fposts%2Fd182bfab.html</url>
    <content type="text"><![CDATA[这几天刚学习了爬虫，准备自己操作一下爬个小说网站使用的requesets获取数据 然后使用xpath解析数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#! /usr/bin/env python# -*- coding:utf-8 -*-import requestsfrom lxml import etreeimport timeclass NovelSpider(object): def __init__(self): self.base_url = &apos;http://www.xbiquge.la&#123;&#125;&apos; self.headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&apos;, &apos;Cookie&apos;: &apos;_abcde_qweasd=0; _abcde_qweasd=0; username=ixieyu&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;&#125; self.data_list = [] # 1.发送请求 def get_response(self,url): response = requests.get(url,headers=self.headers) data = response.content return data # 2.解析数据 获取到文章标题 链接 def parse_list_data(self,data): html = etree.HTML(data) title_list = html.xpath(&quot;//div[@id=&apos;list&apos;]//a/text()&quot;) content_url = html.xpath(&quot;//div[@id=&apos;list&apos;]//a/@href&quot;) for index,title in enumerate(title_list): temp_dict = &#123;&#125; temp_dict[&apos;title&apos;] = title temp_dict[&apos;content_url&apos;] = &apos;http://www.xbiquge.la&apos; + content_url[index] self.data_list.append(temp_dict) # 解析文章页 获取小说标题 内容 def parse_content_data(self,data): html = etree.HTML(data) title_list = html.xpath(&quot;//div[@class=&apos;bookname&apos;]/h1/text()&quot;) content = html.xpath(&quot;//div[@id=&apos;content&apos;]/text()&quot;) self.save_data(title_list[0]) self.save_data(&apos;\n&apos;) for con in content: data = str(con).replace(&apos; &apos;,&apos;&apos;) data1 = data.replace(&apos;;&apos;,&apos;&apos;) self.save_data(data1) # self.save_data(&apos;\n&apos;) # 3.保存数据 def save_data(self,data): with open(&apos;qingyunian.txt&apos;,&apos;a+&apos; ,encoding=&apos;utf-8&apos;)as f: f.write(data) # 4.运行 def start(self): url = self.base_url.format(&apos;/1/1690&apos;) data = self.get_response(url) self.parse_list_data(data) # 遍历data_list 获取文章url for data in self.data_list: content_url = data[&apos;content_url&apos;] print(&apos;正在爬取&apos;+content_url) content_data = self.get_response(content_url) self.parse_content_data(content_data) time.sleep(1) print(&apos;下载完成！&apos;)NovelSpider().start()]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习]]></title>
    <url>%2Fposts%2F28f95297.html</url>
    <content type="text"><![CDATA[十一月四号从哈尔滨西到北京。 周天 一路上幻想办公室生活的趣味，到了地方发现就是一居室的工作室，和我想得出入很大，当天和公司几个人吃了晚饭，水煮鱼。不是中规中矩的写字楼格子间，而是随意的工作、从招标到实施都是几个人完成。 周一 跟雷哥跑业务去招标，发现投标的公司是长安通信，心里好酸啊。早上去的早，公司招标要下午两点开始，没地方去，就在周围公园干坐着三个小时，中午在便利店吃的微波炉加热的便当。当晚上就坐着火车去往了洛阳。 周二 早上到了洛阳，经过了一个小时的公交到达最终的目的地偃师，是一个县级市，我看着也就和龙江差不多，住在酒店，休息了一会就去附近看看房子。下午去办公室报到，就是简单的聊一聊，聊过之后就回酒店苟着了。 周三 上午没事，下午找中介看房子，看了一个两居室的，很破是老房子，好在有家具东西齐全。晚上得到消息周四回郑州。 周四 十点多坐客车去郑州，公司在郑州大学租的公寓，一室一厅很挤，我和雷哥住房间，老陈住客厅。 周五 和老陈去机房看看，帮忙干零活，下午呆了一会，然后晚上十二点机房停运，全忙两个小时。 周六 雷哥说不用我去了，一是 回郑州这边就是帮忙，不用去这么多人，二是 我工作的方向是软件方向和硬件没太多关系。我觉得是 去也帮不了太多忙，浪费时间。上午去小米之家换了电池，溜达了一大圈。晚上去附近走了走，想着去郑州大学里面走一走，绕了好大一圈走到正门口发现要刷卡能进，随即我就骑着小蓝车往回走了！！！！ 周天 上午不想动在宿舍苟着，下午看了电影，晚上出去骑车到广场，比我想象中的要小好多，就和台州商业街那的广场差不多，失望的回来。寻思着晚上弄弄爬虫爬学校的教务处，学校网站还登录不上去了，在之后谢博客写到现在22：58。睡了~晚安]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2F21a87fc2.html</url>
    <content type="text"><![CDATA[记录一下好久都没有的1w步。随着上学期加入实验室，之后大多的时间就是坐在椅子上，每天的活动量大概就是走到食堂的距离吧，每天的运动步数都不超过5k。下午的时候和同学去体育馆打羽毛球，回来之后小臂、大腿酸痛，乳酸堆积。运动之后的舒爽消除了我肩颈酸痛。看来以后还是要劳逸结合。顺便附带手环照。(请忽略我的手腕…)安啦~]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis数据库-操作]]></title>
    <url>%2Fposts%2F8ce91e30.html</url>
    <content type="text"><![CDATA[了解Redis存储数据结构。 数据结构 Redis是key-value的数据结构，每条数据都是一个键值对 键的类型是字符串 注意：键不能重复 值得类型有: 字符串string 哈希hash 列表list 结合set 有序集合zset 数据操作行为 保存 修改 获取 删除 string类型 字符串类型是Redis中最为基础得数据存储类型，它在Redis中是二进制安全得，这便意味着该类型可以接收任何格式得数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型得value最多可以容纳的数据长度是512M。 保存如果设置的键不存在的则为添加，如果设置的键已经存在则修改 设置键值 set key value 设置键为name值为redis set name redis 设置键值及过期时间，以秒为单位 setex key seconds value 设置多个键值 mset key1 value1 key2 value2 … 追加值 append key value 获取 获取:根据键获取值，如果不存在此键则返回nil get key 根据多个键获取多个值 mget key1 key2 删除参看键命令 键命令 查找键,参数支持正则表达式 keys pattern 查看所有键 keys * 查看名称中包含a的键 keys ‘a*’ 判断键是否存在，如果存在返回1，不存在返回 exists key1 查看键对应的value的类型 type key 删除键及对应的值 del key1 key2 … 设置过期时间，以秒为单位 如果没有指定过期时间则⼀直存在，直到使⽤DEL移除 expire key seconds 查看有效时间，以秒为单位 ttl key hash用于存储对象，对象的结构为属性、值值得类型为string 增加、修改 设置单个属性 hset key field value 设置多个属性 hmset key field1 value1 field2 value2 … 获取 获取指定键所有的属性 hkeys key 获取一个属性的值 hget key field 获取多个属性的值 hmget key field1 field2 … 获取所有属性的值 hvals key 删除删除整个hash键及值，使⽤del命令删除属性，属性对应的值会被⼀起删除 hdel key field1 field2 … list列表的元素类型为string按照插入顺序排序 增加 在左侧插⼊数据 lpush key value1 value2 … 在右侧插⼊数据 rpush key value1 value2 … 在指定元素的前或后插⼊新元素 linsert key before或after 现有元素 新元素 获取 返回列表⾥指定范围内的元素 start、stop为元素的下标索引 索引从左侧开始，第⼀个元素为0 索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素 lrange key start stop 设置指定索引位置得元素值 索引从左侧开始，第⼀个元素为0 索引可以是负数，表示尾部开始计数，如-1表示最后⼀个元素 lset key index value 删除 删除指定元素 将列表中前count次出现的值为value的元素移除 count &gt; 0: 从头往尾移除 count &lt; 0: 从尾往头移除 count = 0: 移除所有 lrem key count value set无序集合元素为string元素具有唯一性，不重复说明:对于集合没有修改操作 增加 添加元素 sadd key member1 member2 … 获取 返回所有的元素 smembers key 删除 删除指定元素 srem key value zset类型sorted set，有序集合元素为string类型元素具有唯⼀性，不重复每个元素都会关联一个double类型的score，表示权重，通过权重将元素从⼩到⼤排序说明：没有修改操作 增加 添加 zadd key score1 member1 score2 member2 … 获取 返回指定范围内的元素 start、stop为元素的下标索引 索引从左侧开始，第一个元素为0 索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素 zrange key start stop 返回score值在min和max之间的成员 zrangebyscore key min max 返回成员member的score值 zscore key member 删除 删除指定元素 zrem key member1 member2 … 删除权重在指定范围的元素 zremrangebyscore key min max]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据库]]></title>
    <url>%2Fposts%2Feb52a7b2.html</url>
    <content type="text"><![CDATA[Redis是一个高性能的key-value数据库。 NoSQL数据库:新一类出现的数据库(not only sql),它的特点： 不支持SQL语法 存储结构跟传统关系型数据库中的那种关系表完全不同，nosql中存储的数据都是Kv形式 NoSQL的世界中没有一种通用的语言，每种nosql数据库都有自己的api和语法，以及擅长的业务场景 NoSQL中的产品种类先当多 Mogodb Redis Hbase hadoop Cassandra hadoopRedis简介 Redis是一个开源的使用ANSI C语言编写支持网路，可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API。Redis特性 Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。Redis优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。Reids应用场景 用来做缓存(ehcache/memcached)——redis的所有数据是放在内存中的（内存数据库） 可以在某些特定应用场景下替代传统数据库——比如社交类的应用 在一些大型系统中，巧妙地实现一些特定的功能：session共享、购物车 只要你有丰富的想象力，redis可以用在可以给你无限的惊喜……. Reids官方网站 Reids中文官网]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的坑]]></title>
    <url>%2Fposts%2F1fd52e7b.html</url>
    <content type="text"><![CDATA[Python中的坑早踩早避免。找了很多最后还是github上比较全面详细链接:What the f*ck Python! 复制、浅拷贝、深拷贝 复制：直接赋值,传递对象的引用而已,原始对象改变，被赋值的对象也会做相同的改变 浅拷贝（切片操作、工厂函数、copy函数）：没有拷贝子对象，所以原始数据改变，子对象会改变 深拷贝：包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变 如果在循环引用中的对象定义了 del ,那么python gc不能进行回收，因此，存在内存泄漏的风险 or运算符 1if a == 3 or b == 3 or c == 3: 运行 1if a or b or c == 3: # Wrong 这是由于or的优先级低于==，所以表达式将被评估为if (a) or (b) or (c == 3):。可以使用 1234if a == 3 or b == 3 or c == 3: # Right Way if any([a == 3, b == 3, c == 3]): # Right if any(x == 3 for x in (a, b, c)): # Right if 3 in (a, b, c): # Right 列表的+和+=, append和extend 1234567891011121314151617181920212223242526In [17]: print('ID:', id(a_list))('ID:', 4481323592) In [18]: a_list += [1] In [19]: print('ID (+=):', id(a_list))('ID (+=):', 4481323592) # 使用+= 还是在原来的列表上操作 In [20]: a_list = a_list + [2] In [21]: print('ID (list = list + ...):', id(a_list))('ID (list = list + ...):', 4481293056) # 简单的+其实已经改变了原有列表In [28]: a_list = [] In [29]: id(a_list)Out[29]: 4481326976 In [30]: a_list.append(1) In [31]: id(a_list)Out[31]: 4481326976 # append 是在原有列表添加 In [32]: a_list.extend([2]) In [33]: id(a_list)Out[33]: 4481326976 # extend 也是在原有列表上添加]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flag]]></title>
    <url>%2Fposts%2F71c644a4.html</url>
    <content type="text"><![CDATA[这是一篇加密文章，内容是个人情感宣泄。如果你确实想看，请点击右下角蓝色小图标与我联系。 Incorrect Password! No content to display! U2FsdGVkX1+o0ZRtqxQ4lxSCtNf/hHwMkmLjpeYARb6w8+w8jMTi8fQFUwqZh/RP2FgtEc/YBr1KKeK2O8V6dzztZX5Hvv9Dz+/qG25QrRknl4gDiTufNNNMHNzUVfo3+9jkJ4esfzC7XbhukFJSYgGsTqZhXiy1+wrjCYShIsjQSOSsNmhMfvTM/i/ehrH1JzRNT3oPqatf4isd3F/YAfDknPI5nS72XxLfXpU78S+zLGMJ+A+zrpKWeOEVnoAqpuxpqPpMafJeIUndknqnUEi0XpRBHFJPCYzhiMcyhIM9LQ5eOTk23uleLHqnnaHnoBg7+Cj6qmtOGIyvXb0y2DNWgrevQP04mX0ztUwiYPKD5ZtrCqOyiXm13rD5NVd+ejzTPH5ry3fSfltT3pCnGyymMmsvl1eOrwCxL2J3RaNhU1vCCEDkGTzj2iFblkpzWVRAmmrUlnUwCup21x6U9T/Q2mrkyflSvOSJwkfzcNGOD1eyKqGP5YB6erimxIxcRzKxcCTctFG//3SO2p4C78m6XlGmLIoGV34HDFfLcwB4Z211sqXOhdHGSkvoqsfVF+nWbC5Vk4CeATsbV1XUxn5z1/SfWSL0IL9K8L60JgbGodYfss3ILOeliaB/lOq8R9nFni9noYgV1S9Wbn8GwnTknK4Gkn3E/rX1tzySRxZ6UUJ34T8Zv//Fn/frw5dY3uptqOJ9KxX9+L5mCuVRoppTqIuO4kd76t3+nTlOHa8V+QoDj+e55+qWlSxRf2dVlm5NStNWjTM09SpS8bOs7kwB5z7SiOVJe0g5uxirM42YFJ8qBvrgBqTBj6+NgYQWCg15nyq0UkOtRO7rWOe02HqUPB7vBQxuq7L8YECWkFkwgaPw4LglBlmt/0DqYCn6WF/sKmv8qar18DuSA9+qqSY7+a6mJpzBjoCekHWNbq7JeSaJXAnCxMnAeuDf/TI4A7eqI06ccrbI/qDr7Rbe+gXYx32pbpORLrCqx4FtXiM=]]></content>
      <tags>
        <tag>Flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰Git教程笔记]]></title>
    <url>%2Fposts%2F31ed5d2a.html</url>
    <content type="text"><![CDATA[Git–每一个程序员都必不可少的技能。Git是目前世界上最先进的分布式版本控制系统（没有之一）。 版本控制系统的作用 记录改动 协作编辑 Git的诞生Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们。但是！！！Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！在2008年，GitHub网站上线。 Git命令 新建代码库 12git init 在当前目录新建一个Git代码库 git init [program-name] 新建一个目录，将其初始化为Git代码库 配置 git config （–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 如果不加，那只针对当前的仓库起作用。） 1234567git config --list 显示当前的Git配置 git config --global user.name [username] git config --global user.email [email]git config --global color.ui true 配置Git显示颜色 增加/删除文件 12345678910111213141516git add [filename] 添加指定文件到暂存区(表示添加新文件和编辑过的文件不包括删除的文件)git add [dir] 添加指定目录到暂存区，包括子目录 git add . 添加当前目录的所有文件到暂存区(表示添加新文件和编辑过的文件不包括删除的文件)git add -u 表示添加编辑或者删除的文件，不包括新添加的文件 git rm [filename] 删除工作区文件并放进暂存区如果想从暂存区撤销：git reset HEAD -- [filename]如果想撤销工作区的修改：git checkout -- [filename]注意区别 : rm [filename] 删除工作区文件, 并没有放进暂存区如果想撤销工作区的修改：git checkout -- [filename]git rm --cached [filename] 停止追踪文件，但该文件会保留在工作区(untracked状态) 代码提交 12345678git commit -m [message] 暂存区提交到仓库区git commit [filename1] [filename2] ... -m [message] 暂存区的指定文件提交到仓库区git commit -a -m [message] 工作区中修改后，还未使用git add . 命令添加到暂存区中的文件也一并提交上去 相当于git add . 与git commit –m [message] 两句操作合并为一句进行使用。commit完成过后，git status,下方的工作区是干净的git commit -v 提交时显示所有diff信息 分支 12345678910111213141516171819git branch 列出所有本地分支git branch -r 列出所有远程分支git branch -a 列出所有本地分支和远程分支git branch [branch-name] 新建一个分支，但依然停留在当前分支git checkout -b [branch] 新建一个分支，并切换到该分支git branch --track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系git checkout [branch-name] 切换到指定分支，并更新工作区git branch --set-upstream [branch] [remote-branch] 建立追踪关系，在现有分支与指定的远程分支之间git merge [branch] 合并指定分支到当前分支 git branch -d [branch-name] 删除分支 标签 1234567891011121314151617git tag 列出所有taggit tag [tag] 新建一个tag在当前commitgit tag [tag] [commit] 新建一个tag在指定commitgit tag -d [tag] 删除本地taggit push origin :refs/tags/[tagName] 删除远程taggit show [tag] 查看tag信息git push [remote] [tag] 提交指定taggit push [remote] --tags 提交所有taggit checkout -b [branch] [tag] 新建一个分支，指向某个tag 查看信息 12345678910111213141516171819git status 显示有变更的文件git log 显示当前分支的版本历史git log --stat 显示commit历史，以及每次commit发生变更的文件git log -p [file] 显示指定文件相关的每一次diff‘git log -5 --pretty --oneline 显示过去5次提交git shortlog -sn 显示所有提交过的用户，按提交次数排序git blame [file] 显示指定文件是什么人在什么时间修改过git diff 显示暂存区和工作区的差异git diff --cached [file] 显示工作区与当前分支最新commit之间的差异git reflog 显示当前分支的最近几次提交 远程同步 123456789101112131415git fetch [remote] 下载远程仓库的所有变动git remote -v 显示所有远程仓库 git remote show [remote] 显示某个远程仓库的信息git remote add [shortname] [url] 增加一个新的远程仓库，并命名git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并git push [remote] [branch] 上传本地指定分支到远程仓库git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突git push [remote] --all 推送所有分支到远程仓库 撤销 1234567891011121314151617181920git checkout [file] 恢复暂存区的指定文件到工作区git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区git checkout . 恢复暂存区的所有文件到工作区git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset --hard 重置暂存区与工作区，与上一次commit保持一致git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset --hard [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --keep [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变git revert [commit] 新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支git stashgit stash pop 暂时将未提交的变化移除，稍后再移入]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyhton中内建函数]]></title>
    <url>%2Fposts%2F6610edc8.html</url>
    <content type="text"><![CDATA[内建函数 hasattrhasattr()函数用于判断对象是否包含对应的属性，返回False/True hasattr(object, name)object –对象name – 字符串，属性名]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019书单]]></title>
    <url>%2Fposts%2F8c42af6d.html</url>
    <content type="text"><![CDATA[2019年书单 图解HTTP 大秦帝国 最近看完科幻小说，突然想看点有关于历史的书，被安利的好久的大秦帝国被我下到了kindle里，大秦帝国这本书太厚了，可能好久都看不完….]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[元旦快乐！]]></title>
    <url>%2Fposts%2F66b768da.html</url>
    <content type="text"><![CDATA[元旦快乐！ 最近懒得都没写2018的总结。 希望在2019年：坚持做到每个月的阅读量比上一个月的高。不要等到书到用时方恨少！读书，可以让你遇到更好的人，见到更精彩的世界，让自己拥有更好更多的选择。不要等到年纪大了才遗憾：是年轻时读书太少！多读书，读好书，好读书，趁现在还来得及。最后要时常打电话给家人。]]></content>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2F16ac1d86.html</url>
    <content type="text"><![CDATA[最近电脑做了双系统，win+Ubuntu。沉迷于Ubuntu的环境，感觉Ubuntu的操作界面很高效、简洁。然后就是最近上午校内实习，下午就忙着看机器学习。可能好久都不会来win上面更新了….等什么时候有心情了，有什么想说的了，在来倾诉一番吧。]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决Ubuntu终端中的Vi不听话]]></title>
    <url>%2Fposts%2Fa5ead307.html</url>
    <content type="text"><![CDATA[在装好Ubuntu后，使用Vi来修改文件时，发现好像不太对劲.在编辑模式下，我的方向键都不会移动方向，反而变成输出字母ABCD。然后Backspace（退格键）也无法删除编辑错误的东西，只能使用Delete键来删除。这次我觉得不再是版本的问题了，于是上网找了找。 解决方案用root权限来编辑/etc/vim/vimrc.tiny文件。做如下修改：12set compatible -&gt; set nocompatiblesetbackspace=2]]></content>
  </entry>
  <entry>
    <title><![CDATA[双十一]]></title>
    <url>%2Fposts%2F6650375a.html</url>
    <content type="text"><![CDATA[汪汪汪！]]></content>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立冬]]></title>
    <url>%2Fposts%2F50f733a7.html</url>
    <content type="text"><![CDATA[立冬了。立冬补冬，补嘴空。 二餐的人太多，就没能吃上饺子，想吃玉米肉的！馋…]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2F82a02628.html</url>
    <content type="text"><![CDATA[为什么在想学习的时候就会有其他的事情发生？ &#160; &#160; &#160; &#160;想着在周末的时候看看视频学学习，就被老师叫去实验室帮忙。&#160; &#160; &#160; &#160;想着下午学习看书，一定会有其他的事情来打扰你。&#160; &#160; &#160; &#160;所以我觉得学习的黄金时间就是深夜。当人们都睡着了、没有一丝嘈杂的声音，正是我们开始学习的最佳时刻。我记得作家巴尔扎克的写作时间是凌晨一点到五点，休息片刻写到八点左右，每天用五十杯咖啡来刺激写作，白天的时间用来睡觉和接待客人。路遥也是早晨从中午开始，每天晚上陪他的是两只老鼠。晚上的时间是他们效率最高的时候。而程序员靠的不是晚上的灵光乍现，是因为白天的碌碌无为而产生的愧疚感。&#160; &#160; &#160; &#160;好啦，今天就这样啦，洗洗睡。睡醒过后，明天又是正能量满满的一天。&#160; &#160; &#160; &#160;晚安！]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2F6cae4704.html</url>
    <content type="text"><![CDATA[&#160; 为什么要自己制作一个博客呢？在微博上面，空间写写不好么？ 微博，空间固然很方便，但是也太low了。满足不了自己的这颗臭牛逼的心，结合自己的专业，决定动手搭建个人博客才符合自己的胃口。&#160; &#160; &#160; &#160;首先说说一开始的坑，最开始一块钱在腾讯云上面注册个域名，后来在知乎上面都说阿里云的服务器主机比较好，在阿里云买了一个月的学生机，发现没有备案码，需要买三个月以上才能备案，得，买！！！，续费两个月，才发现腾讯的域名只能用腾讯的主机。gg。又回归阿里注册个域名。申请备案，身份证照片、网站真实性检验单都打印了，最后发现需要注册人手机号的三个月的消费账单，还必须是实名本人的，手上三个手机号，没有一个是自己实名的。在纠结犹豫着要不要周末回家备个案的时候，浏览到腾讯云备案没那么苛刻，不需要消费账单，兜兜转转还是你腾讯云。很快提交了各种资料，客服下午就打来电话，要求改一下不符合的地方。 现在坐等幕布，然后拍照到管局审核。&#160; &#160; &#160; &#160;在等幕布的时候发现制作个人博客不需要主机备案，在github上托管仓库，用hexo在本地制作就可以了，甚至域名解析都不用。看到这里我哭了。手里抓着钱包心痛。&#160; &#160; &#160; &#160;最后觉得时间过得太快了，一眨眼我都大三了，觉得什么都没学到，看的python也看一章忘一章，觉得时间留不住，还是记录在纸上才能留存下去。我想让时间慢下来，每个假期哪儿也不去，看窗外的四季变化，在窗子里思念过去，把文字排列整齐。]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[摘录]]></title>
    <url>%2Fposts%2F9b6a3ba2.html</url>
    <content type="text"><![CDATA[我眼中的世界非黑即白，而你是色彩，是我人生中的全部色彩。那即将缠绕他一生的笑声，每次都像有什么东西光着脚丫在他的胸膛内奔跑从没听过如此动人的声音 她说话的样子就像随时都会笑出声来 而她笑出声的时候 欧维觉得那笑声像是香槟泡沫发出的声音要是有人问起，他会说，在她之前，他没有生活。之后也没有。对于死亡最大的恐惧，在于它与我们擦肩而过，留下我们独自一人 《一个叫欧维的男人决定去死》]]></content>
      <categories>
        <category>摘录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如你所愿]]></title>
    <url>%2Fposts%2Fff3f73a2.html</url>
    <content type="text"><![CDATA[生而为人，我很抱歉 &#160; &#160; &#160; &#160;今天看完了被嫌弃的松子的一生，首先要自爱 才能值得别人去爱你，其实很羡慕松子，松子能够在人生的每一个阶段每一个抉择的时候都能够按照内心的指示去选择，哪怕是这个选择是众人所弃之，所不齿的，松子都能够很好的选择，反观我们，犹犹豫豫，慌慌张张，连一个晚上去洗脸都要拉上一个室友去。如此一比，顿时感觉我们却少的是忍受孤独的能力。&#160; &#160; &#160; &#160;文中有这样一个片段，松子在失手杀掉小野寺，在监狱考取理发师的资格，出狱后本应该在 茜 店里面安稳，踏实的去过普通的生活，没想到遇见了初中时的学生 龙洋一，龙洋一对松子表明了自己的爱意，不嫌弃松子之前有杀过人，和小白脸同居过，当过土耳其女郎，以及和作家的厮混，这些的这些他都不介意。读到这时的我本以为松子就会和龙洋一这样渡过一生，不在困难。没想到龙洋一的身份并不是简单的司机，而是运贩毒品的小弟，同时也是一个不单纯的警察卧底，在他提出想放弃这样混沌的生活，警察以及社团都没有放过他，社团大哥知道龙洋一和松子躲在的旅店，给了他24小时的时间，让他最后享受一回，时间一到，要么大哥杀进去，要么给龙洋一自杀的机会，这也是大哥最后的仁慈。旅店内 他们凭着冰毒的劲头，疯狂的做爱，说着情话，幻想着未来，在最后的时刻，龙洋一拨通了报警电话，留住了自己一命，同时因为吸毒贩毒、龙洋一处以四年的刑期，松子被判了一年，在松子出狱的时候，她傻傻的希望和龙洋一结婚，并对龙洋一寄去了结婚申请书，这时的龙洋一突然觉得自己配不上松子，觉得这么多年来都是他害得松子这样，没有签申请书。而松子以为这只是龙洋一 一时小孩子脾气犯了 松子在监狱附近找了一家理发店工作，每天上班骑车的路上能路过监狱的围墙，她会自言自语也是对着围墙里面的龙洋一说话，自己叨扰着 要加油啊！龙洋一 今天天气不错呢 你还好吗…… 松子每天很努力的工作，每天的目标都定在了三年后他出狱的时候，每天重复着，上班，对着围墙讲话，工作，下班回家，重复前一天，生活很有动力。三年一晃而过，今天就是龙洋一出狱的时候了，她早早的起床，闷了饭，煮了汤，做了他最爱吃的菜，并想到等一起回到家后再炒鸡蛋，换上了准备了好久的内衣，外套。远远的站在监狱大门外等候着，咔嗒大门开了，龙洋一瞪大了双眼，惊奇的看着她，松子小跑上去想抱住他，却被他一把推开了，他本以为松子这么多年应该忘记了他，他抢走了松子的钱，跑开了，留下松子站在原地喊着，龙洋一那边不是回家的方向啊，我在这里。&#160; &#160; &#160; &#160;读到这里我再也忍受不住，眼泪不禁的往外流，心酸，那时的我就好像站在了松子的身后，看着龙洋一跑开，心中的苦涩，一瞬间慌了神三年的目标，就在这一瞬间瓦解。&#160; &#160; &#160; &#160;对不起，生而为人，我很抱歉。&#160; &#160; &#160; &#160;晚安。06.18-23:57]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>被嫌弃的松子的一生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2Ff211d1c6.html</url>
    <content type="text"><![CDATA[&#160; &#160; &#160; &#160;最孤单的人分为两种，一种是恨不得全世界的都跟他一样倒霉，一种则希望别人能幸福，因为看到幸福的人，他也略略温暖。]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2Fposts%2Ff7d18982.html</url>
    <content type="text"><![CDATA[感谢你来到我的小站，这将是我记录生活的地方。记录是一件拯救生命的决定。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
