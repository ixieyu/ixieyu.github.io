<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DRF框架 (九)]]></title>
    <url>%2Fposts%2Fe348dc79.html</url>
    <content type="text"><![CDATA[drf偏移分页组件paginations.py 1234567891011121314from rest_framework.pagination import LimitOffsetPaginationclass MyLimitOffsetPagination(LimitOffsetPagination): # ?offset=从头偏移的条数&amp;limit=要显示的条数 limit_query_param = &apos;limit&apos; offset_query_param = &apos;offset&apos; # ?不传offset和limit默认显示前3条，只设置offset就是从偏移位往后再显示3条 default_limit = 3 # ?limit可以自定义一页显示的最大条数 max_limit = 5 #eg:/cars/?offset=1&amp;limit=4 往后偏移一位，然后往后数四个数据 # 只使用limit结合ordering可以实现排行前几或后几 #？ordering=-price&amp;limit=2 价格降序，取最前面两条数据 views.py 123456789from rest_framework.generics import ListAPIViewclass CarListAPIView(ListAPIView): # 如果queryset没有过滤条件，就必须 .all()，不然分页会出问题 queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 分页组件 - 给视图类配置分页类即可 - 分页类需要自定义，继承drf提供的分页类即可 pagination_class = pagenations.MyLimitOffsetPagination drf游标分页组件（了解）paginations.py 12345678910# 注：必须基于排序规则下进行分页# 1）如果接口配置了OrderingFilter过滤器，那么url中必须传ordering# 1）如果接口没有配置OrderingFilter过滤器，一定要在分页类中声明ordering按某个字段进行默认排序from rest_framework.pagination import CursorPaginationclass MyCursorPagination(CursorPagination): cursor_query_param = &apos;cursor&apos; page_size = 3 page_size_query_param = &apos;page_size&apos; max_page_size = 5 ordering = &apos;-pk&apos; views.py 123456789from rest_framework.generics import ListAPIViewclass CarListAPIView(ListAPIView): # 如果queryset没有过滤条件，就必须 .all()，不然分页会出问题 queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 分页组件 - 给视图类配置分页类即可 - 分页类需要自定义，继承drf提供的分页类即可 pagination_class = pagenations.MyCursorPagination 自定义过滤器filters.py 123456789# 自定义过滤器，接口：?limit=显示的条数class LimitFilter: def filter_queryset(self, request, queryset, view): # 前台固定用 ?limit=... 传递过滤参数 limit = request.query_params.get(&apos;limit&apos;) if limit: limit = int(limit) return queryset[:limit] return queryset views.py 1234567891011from rest_framework.generics import ListAPIViewclass CarListAPIView(ListAPIView): # 如果queryset没有过滤条件，就必须 .all()，不然分页会出问题 queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 局部配置 过滤类 们（全局配置用DEFAULT_FILTER_BACKENDS） filter_backends = [LimitFilter] 接口：/?limit=5 显示5条数据 过滤器插件：django-filter安装 1pip install django-filter 过滤条件层：自定义app01/filters.py 1234567891011121314# django-filter插件过滤器类from django_filters.rest_framework.filterset import FilterSetfrom . import models# 自定义过滤字段from django_filters import filtersclass CarFilterSet(FilterSet): min_price = filters.NumberFilter(field_name=&apos;price&apos;, lookup_expr=&apos;gte&apos;) max_price = filters.NumberFilter(field_name=&apos;price&apos;, lookup_expr=&apos;lte&apos;) class Meta: model = models.Car fields = [&apos;brand&apos;, &apos;min_price&apos;, &apos;max_price&apos;] # brand是model中存在的字段，一般都是可以用于分组的字段 # min_price、max_price是自定义字段，需要自己自定义过滤条件 视图层：views.py 123456789101112131415# django-filter插件过滤器from django_filters.rest_framework import DjangoFilterBackendfrom .filters import CarFilterSetclass CarListAPIView(ListAPIView): queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 局部配置 过滤类 们（全局配置用DEFAULT_FILTER_BACKENDS） filter_backends = [DjangoFilterBackend] # django-filter过滤器插件使用 filter_class = CarFilterSet # 接口：?brand=...&amp;min_price=...&amp;max_price=... # eg:?brand=宝马&amp;min_price=5&amp;max_price=10 =&gt; 5~10间的宝马牌汽车]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架 (八)]]></title>
    <url>%2Fposts%2Fff99369d.html</url>
    <content type="text"><![CDATA[自定义drf-jwt手动签发和校验签发token源码入口 12345678前提：给一个局部禁用了所有 认证与权限 的视图类发送用户信息得到token，其实就是登录接口，不然进不了登录页面获取提交的username和password1）rest_framework_jwt.views.ObtainJSONWebToken 的 父类 JSONWebTokenAPIView 的 post 方法 接受有username、password的post请求校验数据，并且签发token2）post方法将请求数据交给 rest_framework_jwt.serializer.JSONWebTokenSerializer 处理 完成数据的校验，会走序列化类的 全局钩子校验规则，校验得到登录用户并签发token存储在序列化对象中 核心源码：rest_framework_jwt.serializer.JSONWebTokenSerializer的validate(self,attrs)方法 12345678910111213141516171819202122232425262728def validate(self, attrs): # 账号密码字典 credentials = &#123; self.username_field: attrs.get(self.username_field), &apos;password&apos;: attrs.get(&apos;password&apos;) &#125; if all(credentials.values()): # 签发token第1步：用账号密码得到user对象 user = authenticate(**credentials) if user: if not user.is_active: msg = _(&apos;User account is disabled.&apos;) raise serializers.ValidationError(msg) # 签发token第2步：通过user得到payload，payload包含着用户信息与过期时间 payload = jwt_payload_handler(user) # 在视图类中，可以通过 序列化对象.object.get(&apos;user&apos;或者&apos;token&apos;) 拿到user和token return &#123; # 签发token第3步：通过payload签发出token &apos;token&apos;: jwt_encode_handler(payload), &apos;user&apos;: user &#125; else: msg = _(&apos;Unable to log in with provided credentials.&apos;) raise serializers.ValidationError(msg) else: msg = _(&apos;Must include &quot;&#123;username_field&#125;&quot; and &quot;password&quot;.&apos;) msg = msg.format(username_field=self.username_field) raise serializers.ValidationError(msg) 手动签发token逻辑 （主要就是jwt_payload_handler和jwt_encode_handler这两个方法，在源码settings中生成token） 123451）通过username、password得到user对象2）通过user对象生成payload：jwt_payload_handler(user) =&gt; payload from rest_framework_jwt.serializers import jwt_payload_handler3）通过payload签发token：jwt_encode_handler(payload) =&gt; token from rest_framework_jwt.serializers import jwt_encode_handler 签发token总结 1234jwt_payload_handler方法传入登录对象，返回payload(包含用户信息，过期时间)jwt_encode_handler方法传入payload,返回一个加密的token流程：获取登录用户对象user---&gt;jwt_payload_handler(user)生成payload(包含用户信息和过期时间)---&gt;jwt_encode_handler(payload)生成一个加密的token 校验token源码入口 1234前提：访问一个配置了jwt认证规则的视图类，就需要提交认证字符串token，在认证类中完成token的校验1）rest_framework_jwt.authentication.JSONWebTokenAuthentication 的 父类 BaseJSONWebTokenAuthentication 的 authenticate 方法 请求头拿认证信息jwt-token =&gt; 通过反爬小规则确定有用的token =&gt; payload =&gt; user 核心源码： rest_framework_jwt.authentication.BaseJSONWebTokenAuthentication的authenticate(self,request)方法 123456789101112131415161718192021222324252627def authenticate(self, request): &quot;&quot;&quot; Returns a two-tuple of `User` and token if a valid signature has been supplied using JWT-based authentication. Otherwise returns `None`. &quot;&quot;&quot; # 带有反爬小规则的获取token：前台必须按 &quot;jwt token字符串&quot; 方式提交 # 校验user第1步：从请求头 HTTP_AUTHORIZATION 中拿token，并提取 jwt_value = self.get_jwt_value(request) # 游客 if jwt_value is None: return None # 校验 try: # 校验user第2步：token =&gt; payload payload = jwt_decode_handler(jwt_value) except jwt.ExpiredSignature: msg = _(&apos;Signature has expired.&apos;) raise exceptions.AuthenticationFailed(msg) except jwt.DecodeError: msg = _(&apos;Error decoding signature.&apos;) raise exceptions.AuthenticationFailed(msg) except jwt.InvalidTokenError: raise exceptions.AuthenticationFailed() # 校验user第3步：payload =&gt; user user = self.authenticate_credentials(payload) return (user, jwt_value) 手动校验token逻辑 123451）从请求头中获取token2）根据token解析出payload：jwt_decode_handler(token) =&gt; payloay from rest_framework_jwt.authentication import jwt_decode_handler3）根据payload解析出user：self.authenticate_credentials(payload) =&gt; user 继承drf-jwt的BaseJSONWebTokenAuthentication，拿到父级的authenticate_credentials方法 校验token总结 1从请求头中获取token---&gt;jwt_decode_handler(token)获取到payloay---&gt;self.authenticate_credentials(payload)获取到user 案例：实现多方式登录签发tokenmodels.py 12345678910111213from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass User(AbstractUser): mobile = models.CharField(max_length=11, unique=True) class Meta: db_table = &apos;api_user&apos; verbose_name = &apos;用户表&apos; verbose_name_plural = verbose_name def __str__(self): return self.username serializers.py 生成token 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#生成token的两个函数 user=&gt;payload=&gt;tokenfrom rest_framework_jwt.serializers import jwt_payload_handlerfrom rest_framework_jwt.serializers import jwt_encode_handlerfrom rest_framework import serializersfrom . import modelsimport re# 1) 前台提交多种登录信息都采用一个key，所以后台可以自定义反序列化字段进行对应# 2) 序列化类要处理序列化与反序列化，要在fields中设置model绑定的Model类所有使用到的字段# 3) 区分序列化字段与反序列化字段 read_only | write_only# 4) 在自定义校验规则中（局部钩子、全局钩子）校验数据是否合法、确定登录的用户、根据用户签发token# 5) 将登录的用户与签发的token保存在序列化类对象中#前台有两个输入框：一个账号框(可以填用户名、手机号、邮箱)usr，一个密码框 pwdclass UserModelSerializer(serializers.ModelSerializer): # 自定义反序列字段：一定要设置write_only，只参与反序列化，不会与model类字段映射 usr = serializers.CharField(write_only=True) pwd = serializers.CharField(write_only=True) class Meta: model=models.User fields = [&apos;usr&apos;, &apos;pwd&apos;, &apos;username&apos;, &apos;mobile&apos;, &apos;email&apos;] # 系统校验规则和前面write_only设计方式一样 extra_kwargs = &#123; &apos;username&apos;: &#123; &apos;read_only&apos;: True &#125;, &apos;mobile&apos;: &#123; &apos;read_only&apos;: True &#125;, &apos;email&apos;: &#123; &apos;read_only&apos;: True &#125;, &#125; #全局钩子，校验数据 def validate(self, attrs): usr = attrs.get(&apos;usr&apos;) pwd = attrs.get(&apos;pwd&apos;) # 多方式登录：各分支处理得到该方式下对应的用户 if re.match(r&apos;.+@.+&apos;, usr): #判断是否是邮箱登录 user_query = models.User.objects.filter(email=usr) elif re.match(r&apos;1[3-9][0-9]&#123;9&#125;&apos;, usr): #判断是否是手机号登录 user_query = models.User.objects.filter(mobile=usr) else: #用户名登录 user_query = models.User.objects.filter(username=usr) user_obj = user_query.first() # 签发token：得到登录用户，签发token并存储在实例化对象中 if user_obj and user_obj.check_password(pwd): # 签发token，将token存放到 实例化类对象的token 名字中 pyload = jwt_payload_handler(user_obj) token = jwt_encode_handler(pyload) # 将当前用户与签发的token都保存在序列化对象中 self.user = user_obj self.token = token return attrs raise serializers.ValidationError(&#123;&apos;data&apos;: &apos;数据有误&apos;&#125;) 结果只显示fields中的read_only字段 视图层：views.py 123456789101112131415161718192021222324252627282930313233343536373839404142#实现多方式登陆签发token：账号、手机号、邮箱等登陆# 1) 禁用认证与权限组件# 2) 拿到前台登录信息，交给序列化类# 3) 序列化类校验得到登录用户与token存放在序列化对象中# 4) 取出登录用户与token返回给前台import refrom . import serializers, modelsfrom utils.response import APIResponsefrom rest_framework.views import APIViewfrom rest_framework_jwt.serializers import jwt_payload_handlerfrom rest_framework_jwt.serializers import jwt_encode_handlerclass LoginAPIView(APIView): # 1) 禁用认证与权限组件 authentication_classes = [] permission_classes = [] def post(self, request, *args, **kwargs): # 2) 拿到前台登录信息，交给序列化类，规则：账号用usr传，密码用pwd传 user_ser = serializers.UserModelSerializer(data=request.data) # 3) 序列化类校验得到登录用户与token存放在序列化对象中 user_ser.is_valid(raise_exception=True) # 4) 取出登录用户与token返回给前台 return APIResponse(token=user_ser.token, results=serializers.UserModelSerializer(user_ser.user).data) # &quot;一根筋&quot; 思考方式：所有逻辑都在视图类中处理 def my_post(self, request, *args, **kwargs): usr = request.data.get(&apos;usr&apos;) pwd = request.data.get(&apos;pwd&apos;) if re.match(r&apos;.+@.+&apos;, usr): user_query = models.User.objects.filter(email=usr) elif re.match(r&apos;1[3-9][0-9]&#123;9&#125;&apos;, usr): user_query = models.User.objects.filter(mobile=usr) else: user_query = models.User.objects.filter(username=usr) user_obj = user_query.first() if user_obj and user_obj.check_password(pwd): payload = jwt_payload_handler(user_obj) token = jwt_encode_handler(payload) return APIResponse(results=&#123;&apos;username&apos;: user_obj.username&#125;, token=token) return APIResponse(data_msg=&apos;不可控错误&apos;) 使用Postman,post请求,json格式传参 usr和pwd,返回用户信息和token值 案例：自定义认证反爬规则校验tokenauthentications.py 123456789101112131415161718192021222324252627282930313233import jwtfrom rest_framework_jwt.authentication import BaseJSONWebTokenAuthenticationfrom rest_framework_jwt.authentication import jwt_decode_handlerfrom rest_framework.exceptions import AuthenticationFailedclass JWTAuthentication(BaseJSONWebTokenAuthentication): def authenticate(self, request): #从前端取出token值，放在HTTP_AUTHORIZATION中 jwt_token = request.META.get(&apos;HTTP_AUTHORIZATION&apos;) # 自定义校验规则：auth token jwt token = self.parse_jwt_token(jwt_token) if token is None: return None try: # token =&gt; payload payload = jwt_decode_handler(token) except jwt.ExpiredSignature: raise AuthenticationFailed(&apos;token已过期&apos;) except: raise AuthenticationFailed(&apos;非法用户&apos;) # payload =&gt; user user = self.authenticate_credentials(payload) return (user, token) #获取到登录对象和签发的token # 自定义校验规则：auth token jwt，auth为前盐，jwt为后盐 def parse_jwt_token(self, jwt_token): tokens = jwt_token.split() if len(tokens) != 3 or tokens[0].lower() != &apos;auth&apos; or tokens[2].lower() != &apos;jwt&apos;: return None return tokens[1] views.py 1234567891011from rest_framework.views import APIViewfrom utils.response import APIResponse# 必须登录后才能访问 - 通过了认证权限组件from rest_framework.permissions import IsAuthenticated# 自定义jwt校验规则from .authentications import JWTAuthenticationclass UserDetail(APIView): authentication_classes = [JWTAuthentication] #返回user对象和token permission_classes = [IsAuthenticated] def get(self, request, *args, **kwargs): return APIResponse(results=&#123;&apos;username&apos;: request.user.username&#125;) 群查接口各种筛选组件数据准备 models.py 123456789101112class Car(models.Model): name = models.CharField(max_length=16, unique=True, verbose_name=&apos;车名&apos;) price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=&apos;价格&apos;) brand = models.CharField(max_length=16, verbose_name=&apos;品牌&apos;) class Meta: db_table = &apos;api_car&apos; verbose_name = &apos;汽车表&apos; verbose_name_plural = verbose_name def __str__(self): return self.name admin.py 1admin.site.register(models.Car) serializers.py 1234class CarModelSerializer(serializers.ModelSerializer): class Meta: model = models.Car fields = [&apos;name&apos;, &apos;price&apos;, &apos;brand&apos;] views.py 123456# Car的群查接口from rest_framework.generics import ListAPIViewclass CarListAPIView(ListAPIView): queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer urls.py 1url(r&apos;^cars/$&apos;, views.CarListAPIView.as_view()), drf搜索过滤组件views.py 搜索组件使用方法：路由后缀加 /?search=1 (name和price中包含1的数据都会被查询出来) 1234567891011121314from rest_framework.generics import ListAPIView # 第一步：drf的SearchFilter - 搜索过滤from rest_framework.filters import SearchFilterclass CarListAPIView(ListAPIView): queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer #自定义认证 # 第二步：局部配置 过滤类 们（全局配置用DEFAULT_FILTER_BACKENDS） filter_backends = [SearchFilter] # 第三步：SearchFilter过滤类依赖的过滤条件 =&gt; 接口：/cars/?search=... search_fields = [&apos;name&apos;, &apos;price&apos;] #筛选字段 # eg：/cars/?search=1，name和price中包含1的数据都会被查询出 drf排序过滤组件views.py 123456789101112131415from rest_framework.generics import ListAPIView# 第一步：drf的OrderingFilter - 排序过滤from rest_framework.filters import OrderingFilterclass CarListAPIView(ListAPIView): queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 第二步：局部配置 过滤类 们（全局配置用DEFAULT_FILTER_BACKENDS） filter_backends = [OrderingFilter] # 第三步：OrderingFilter过滤类依赖的过滤条件 =&gt; 接口：/cars/?ordering=... ordering_fields = [&apos;pk&apos;, &apos;price&apos;] # eg：/cars/?ordering=-price,pk，先按price降序，如果出现price相同，再按pk升序 drf基础分页组件paginations.py 1234567891011from rest_framework.pagination import PageNumberPaginationclass MyPageNumberPagination(PageNumberPagination): # ?page=页码 定义代表页码的属性，如果写pages,就是?pages=页码 page_query_param = &apos;page&apos; # ?page=页码 设置默认下一页显示的条数 page_size = 3 # ?page=页码&amp;page_size=条数 用户自定义一页显示的条数 page_size_query_param = &apos;page_size&apos; # 用户自定义一页显示的条数最大限制：数值超过5也只显示5条 max_page_size = 5 views.py 123456789101112from rest_framework.generics import ListAPIViewclass CarListAPIView(ListAPIView): # 如果queryset没有过滤条件，就必须 .all()，不然分页会出问题 queryset = models.Car.objects.all() serializer_class = serializers.CarModelSerializer # 分页组件 - 给视图类配置分页类即可 - 分页类需要自定义，继承drf提供的分页类即可 pagination_class = pagenations.MyPageNumberPagination #eg:/cars/ 显示第一页三条 /cars/?page=2&amp;page_size=4 每页显示4条，显示第二页的4条]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架 (七)]]></title>
    <url>%2Fposts%2F36cb8991.html</url>
    <content type="text"><![CDATA[drf频率组件源码1.APIView的dispatch方法的 self.initial(request,*args,**kwargs) 点进去 2.self.check_throttles(request) 进行频率认证 123456789101112131415161718def initial(self, request, *args, **kwargs): &quot;&quot;&quot; Runs anything that needs to occur prior to calling the method handler. &quot;&quot;&quot; self.format_kwarg = self.get_format_suffix(**kwargs) # Perform content negotiation and store the accepted info on the request neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg # Determine the API version, if versioning is in use. version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) #频率认证 3.self.get_throttles() 频率组件最终要的两个方法：allow_request()和wait() 123456789def check_throttles(self, request): #频率组件核心代码 &quot;&quot;&quot; Check if request should be throttled. Raises an appropriate exception if the request is throttled. &quot;&quot;&quot; throttle_durations = [] for throttle in self.get_throttles(): if not throttle.allow_request(request, self): throttle_durations.append(throttle.wait()) 3-1. self.throttle_classes 出现频率配置settings信息，经过查询源码的settings文件对频率配置为空 12345def get_throttles(self): &quot;&quot;&quot; Instantiates and returns the list of throttles that this view uses. &quot;&quot;&quot; return [throttle() for throttle in self.throttle_classes] #频率组件配置信息 allow_request() 在自身、所在类都没有找到，那去父类找,在源码throttling.py中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class SimpleRateThrottle(BaseThrottle): cache = default_cache timer = time.time cache_format = &apos;throttle_%(scope)s_%(ident)s&apos; scope = None THROTTLE_RATES = api_settings.DEFAULT_THROTTLE_RATES def __init__(self): if not getattr(self, &apos;rate&apos;, None): self.rate = self.get_rate() #3.rate值就是方法get_rate的返回值（频率次数） self.num_requests, self.duration = self.parse_rate(self.rate) def get_cache_key(self, request, view): raise NotImplementedError(&apos;.get_cache_key() must be overridden&apos;) #get_rate最后返回的结果是设置的频率次数 def get_rate(self):#1.在自定义类中要给scope属性赋值 if not getattr(self, &apos;scope&apos;, None): msg = (&quot;You must set either `.scope` or `.rate` for &apos;%s&apos; throttle&quot; % self.__class__.__name__) raise ImproperlyConfigured(msg) try: return self.THROTTLE_RATES[self.scope] #2.在settings文件中配置scope属性值对应的value except KeyError: msg = &quot;No default throttle rate set for &apos;%s&apos; scope&quot; % self.scope raise ImproperlyConfigured(msg) def parse_rate(self, rate): if rate is None: return (None, None) num, period = rate.split(&apos;/&apos;) #4.rate有值，根据源码，自定义的rate值是一个字符串，而且是这种格式：&apos;数字/以s,m,h,d之类开头的字母&apos; num_requests = int(num) #5.获得的数字就是设置的频率次数 duration = &#123;&apos;s&apos;: 1, &apos;m&apos;: 60, &apos;h&apos;: 3600, &apos;d&apos;: 86400&#125;[period[0]] #6.获得是间隔的时间（以秒为单位） return (num_requests, duration) #7.数据返回给__init__，解压赋值 def allow_request(self, request, view): if self.rate is None: return True #get_cache_key就是要重写的方法，若不重写，会直接抛出异常 self.key = self.get_cache_key(request, view) #8.自定义的时候需要重写的方法，有返回值，放入缓存中 if self.key is None: return True self.history = self.cache.get(self.key, []) #9.获取缓存，通过key取值 self.now = self.timer() #10.当前时间 # Drop any requests from the history which have now passed the # throttle duration while self.history and self.history[-1] &lt;= self.now - self.duration: self.history.pop() if len(self.history) &gt;= self.num_requests: return self.throttle_failure() return self.throttle_success() def throttle_success(self): self.history.insert(0, self.now) self.cache.set(self.key, self.history, self.duration) return True def throttle_failure(self): return False #返回距下一次能请求的时间，限制的访问次数在parse_rate可以求出 def wait(self): &quot;&quot;&quot; Returns the recommended next request time in seconds. &quot;&quot;&quot; if self.history: remaining_duration = self.duration - (self.now - self.history[-1]) else: remaining_duration = self.duration available_requests = self.num_requests - len(self.history) + 1 if available_requests &lt;= 0: return None return remaining_duration / float(available_requests) 核心源码分析 123456789101112131415161718192021def check_throttles(self, request): throttle_durations = [] # 1）遍历配置的频率认证类，初始化得到一个个频率认证类对象（会调用频率认证类的 __init__() 方法） # 2）频率认证类对象调用 allow_request 方法，判断是否限次（没有限次可访问，限次不可访问） # 3）频率认证类对象在限次后，调用 wait 方法，获取还需等待多长时间可以进行下一次访问 # 注：频率认证类都是继承 SimpleRateThrottle 类 for throttle in self.get_throttles(): if not throttle.allow_request(request, self): # 只要频率限制了，allow_request 返回False了，才会调用wait throttle_durations.append(throttle.wait()) if throttle_durations: # Filter out `None` values which may happen in case of config / rate # changes, see #1438 durations = [ duration for duration in throttle_durations if duration is not None ] duration = max(durations, default=None) self.throttled(request, duration) 注意： 1主要流程在第四步中标出 自定义频率类123456# 1) 自定义一个继承 SimpleRateThrottle 类 的频率类# 2) 设置一个 scope 类属性，属性值为任意见名知意的字符串# 3) 在settings配置文件中，配置drf的DEFAULT_THROTTLE_RATES，格式为 &#123;scope字符串值: &apos;次数/时间&apos;&#125;# 4) 在自定义频率类中重写 get_cache_key 方法 # 限制的对象返回 与限制信息有关的字符串 # 不限制的对象返回 None (只能放回None，不能是False或是&apos;&apos;等) 写一个短信接口，设置 1/min频率限制 utils.throttles.py 12345678910111213from rest_framework.throttling import SimpleRateThrottleclass SMSRateThrottle(SimpleRateThrottle): scope = &apos;sms&apos; #只对提交手机号的get方法进行限制 def get_cache_key(self, request, view): mobile = request.query_params.get(&apos;mobile&apos;) #没有手机号就不做频率限制 if not mobile: return None #返回的信息可以用手机号动态变化，且不易重复的字符串，作为缓存的key return &apos;throttle_%(scope)s_%(ident)s&apos; % &#123;&apos;scope&apos;: self.scope, &apos;ident&apos;: mobile&#125; settings.py配置： 1234567# drf配置REST_FRAMEWORK = &#123; # 频率限制条件配置 &apos;DEFAULT_THROTTLE_RATES&apos;: &#123; &apos;sms&apos;: &apos;1/min&apos; &#125;,&#125; 视图层：views.py 12345678from .throttles import SMSRateThrottleclass TestSMSAPIView(APIView): # 局部配置频率认证 throttle_classes = [SMSRateThrottle] def get(self, request, *args, **kwargs): return APIResponse(0, &apos;get 获取验证码 OK&apos;) def post(self, request, *args, **kwargs): return APIResponse(0, &apos;post 获取验证码 OK&apos;) 路由：urls.py 1url(r&apos;^sms/$&apos;, views.TestSMSAPIView.as_view()), 会限制的接口 1234# 只会对 /api/sms/?mobile=具体手机号 接口才会有频率限制，设置了限制频率，到达访问次数就会禁止# 1）对 /api/sms/ 或其他接口发送无限制# 2）对数据包提交mobile的/api/sms/接口无限制# 3）对不是mobile（如phone）字段提交的电话接口无限制 JWT认证优点 1231) 服务器不要存储token，token交给每一个客户端自己存储，服务器压力小2）服务器存储的是 签发和校验token 两段算法，签发认证的效率高3）算法完成各集群服务器同步成本低，路由项目完成集群部署（适应高并发） 格式 1234567891011121) jwt token采用三段式：头部.载荷.签名2）每一部分都是一个json字典加密形参的字符串3）头部和载荷采用的是base64可逆加密（前台后台都可以解密）4）签名采用hash256不可逆加密（后台校验采用碰撞校验）5）各部分字典的内容： 头部：基础信息 - 公司信息、项目组信息、可逆加密采用的算法 载荷：有用但非私密的信息 - 用户可公开信息、过期时间 签名：头部+载荷+秘钥 不可逆加密后的结果 注：服务器jwt签名加密秘钥一定不能泄露 签发token：固定的头部信息加密.当前的登陆用户与过期时间加密.头部+载荷+秘钥生成不可逆加密校验token：头部可校验也可以不校验，载荷校验出用户与过期时间，头部+载荷+秘钥完成碰撞检测校验token是否被篡改 drf-jwt插件官网 1https://github.com/jpadilla/django-rest-framework-jwt 安装 1pip install djangorestframework-jwt 登录-签发token(生成token):urls.py 123456# ObtainJSONWebToken视图类就是通过username和password得到user对象然后签发token（生成token）from rest_framework_jwt.views import ObtainJSONWebToken, obtain_jwt_tokenurlpatterns = [ # url(r&apos;^jogin/$&apos;, ObtainJSONWebToken.as_view()), url(r&apos;^jogin/$&apos;, obtain_jwt_token),] 认证-校验token(解析token):全局或者配置drf-jwt的认证类 JSONWebTokenAuthentication 12345678910from rest_framework.views import APIViewfrom utils.response import APIResponse# 必须登录后才能访问 - 通过了认证权限组件from rest_framework.permissions import IsAuthenticatedfrom rest_framework_jwt.authentication import JSONWebTokenAuthenticationclass UserDetail(APIView): authentication_classes = [JSONWebTokenAuthentication] # jwt-token校验request.user permission_classes = [IsAuthenticated] # 结合权限组件筛选掉游客 def get(self, request, *args, **kwargs): return APIResponse(results=&#123;&apos;username&apos;: request.user.username&#125;) 路由与接口测试 12345# 路由url(r&apos;^user/detail/$&apos;, views.UserDetail.as_view()),# 接口：/api/user/detail/# 认证信息：必须在请求头的 Authorization 中携带 &quot;jwt 后台签发的token&quot; 格式的认证字符串 注意： 12341.签发token的时候，只有post请求，没有get请求2.生成token的时候需要通过json传入username和password3.解析token的时候，get请求需要在Headers中传入参数Authorization jwt 用户对应的token值]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架 (六)]]></title>
    <url>%2Fposts%2Fa9c3911b.html</url>
    <content type="text"><![CDATA[drf认证组件 12345678910111213用户信息表from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass User(AbstractUser): mobile = models.CharField(max_length=11,unique=True) class Meta: db_table = &apos;user&apos; verbose_name = &apos;用户表&apos; verbose_name_plural = verbose_name def __str__(self): return self.username 源码分析 12345678910111213141516171.从APIView的dispath(self, request, *args, **kwargs)下手2.dispath方法内 self.initial(request, *args, **kwargs) 进入三大认证 认证组件：校验用户 —游客、合法用户、非法用户 # 游客：代表校验通过，直接进入下一步校验（权限校验） # 合法用户：代表校验通过，将用户存储在request.user中，再进入下一步校验（权限校验） # 非法用户：代表校验失败，抛出异常，返回403权限异常结果 self.perform_authentication(request) #认证组件 权限组件：校验用户权限 - 必须登录、所有用户、登录之后读写，游客只读、自定义用户角色 # 认证通过：可以进入下一步校验（频率认证） # 认证失败：抛出异常，返回403权限异常结果 self.check_permissions(request) #权限组件 频率组件：限制视图接口被访问的频率次数 - 限制的条件(IP、id、唯一键)、频率周期时间(s、m、h)、频率的次数（3/s） # 没有达到限次：正常访问接口 # 达到限次：限制时间内不能访问，限制时间达到后，可以重新访问 self.check_throttles(request) #频率组件 分两方面:a,b（a）:在initial方法上面——这个是源码settings文件配置认证组件的地方12345678910111213def initialize_request(self, request, *args, **kwargs): &quot;&quot;&quot; Returns the initial request object. &quot;&quot;&quot; parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 123def get_authenticators(self): return [auth() for auth in self.authentication_classes] 源码settings.py文件中APISettings类 1234DEFAULT_AUTHENTICATION_CLASSES&apos;: [ &apos;rest_framework.authentication.SessionAuthentication&apos;, #session认证 &apos;rest_framework.authentication.BasicAuthentication&apos; #基础认证 ] (b): self.inital(self,request,*args,**kwargs) 包含认证，权限，频率三大组件123456789101112131415161718def initial(self, request, *args, **kwargs): &quot;&quot;&quot; Runs anything that needs to occur prior to calling the method handler. &quot;&quot;&quot; self.format_kwarg = self.get_format_suffix(**kwargs) # Perform content negotiation and store the accepted info on the request neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg # Determine the API version, if versioning is in use. version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted self.perform_authentication(request) #认证 self.check_permissions(request) #权限 self.check_throttles(request) #频率 （b—1）: self.perform_authentication(request) 认证123456789def perform_authentication(self, request): &quot;&quot;&quot; Perform authentication on the incoming request. Note that if you override this and simply &apos;pass&apos;, then authentication will instead be performed lazily, the first time either `request.user` or `request.auth` is accessed. &quot;&quot;&quot; request.user （b—2）:Request类的 方法属性 user 的get方法12345678910@property def user(self): &quot;&quot;&quot; Returns the user associated with the current request, as authenticated by the authentication classes provided to the request. &quot;&quot;&quot; if not hasattr(self, &apos;_user&apos;): with wrap_attributeerrors(): self._authenticate() return self._user (b—3):self._authenticate()123456789101112131415161718192021222324认证的细则： # 做认证 def _authenticate(self): #这里的self就是request # 遍历拿到一个个认证器，进行认证 # self.authenticators配置的一堆认证类产生的认证类对象组成的 list # 即：[auth() for auth in self.authentication_classes] for authenticator in self.authenticators: try: # 认证器(对象)调用认证方法authenticate(认证类对象self, request请求对象) # 返回值：登陆的用户与认证的信息组成的 tuple # 该方法被try包裹，代表该方法会抛异常，抛异常就代表认证失败 user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise # 返回值的处理 if user_auth_tuple is not None: self._authenticator = authenticator # 如何有返回值，就将 登陆用户 与 登陆认证 分别保存到 request.user、request.auth self.user, self.auth = user_auth_tuple return # 如果返回值user_auth_tuple为空，代表认证通过，但是没有 登陆用户 与 登陆认证信息，代表游客 self._not_authenticated() 自定义认证类从源码的settings文件可以看出,认证类需要继承BasicAuthentication(在authentication.py文件) 1234DEFAULT_AUTHENTICATION_CLASSES&apos;: [ &apos;rest_framework.authentication.SessionAuthentication&apos;, #会重新开启CSRF认证 &apos;rest_framework.authentication.BasicAuthentication&apos; ] 1234567891) 创建继承BaseAuthentication的认证类2) 重写authenticate方法3) 实现体根据认证规则 确定游客、非法用户、合法用户 （根据自己的认证规则）4) 进行全局或局部配置认证规则i.没有认证信息返回None(游客)ii.有认证信息认证失败抛异常(非法用户)iii.有认证信息认证成功返回用户与认证信息元组(合法用户) utils.authentications.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 1）继承BaseAuthentication类# 2）重写authenticate(self, request)方法，自定义认证规则# 3）自定义认证规则基于的条件：# 没有认证信息返回None(游客)# 有认证信息认证失败抛异常(非法用户)# 有认证信息认证成功返回用户与认证信息元组(合法用户)# 4）完全视图类的全局(settings文件中)或局部(确切的视图类)配置from rest_framework.authentication import BaseAuthenticationfrom rest_framework.exceptions import AuthenticationFailed #异常接收from app01 import models#继承BaseAuthenticationclass MyAuthentication(BaseAuthentication): &quot;&quot;&quot; 同前台请求头拿认证信息auth（获取认证的字段要与前台约定） 没有auth是游客，返回None 有auth进行校验 失败是非法用户，抛出异常 成功是合法用户，返回 (用户, 认证信息) &quot;&quot;&quot; def authenticate(self, request): #重写authenticate方法 #前台在请求头携带认证信息， #且默认规范用 Authorization 字段携带认证信息， #后台固定在请求对象的META字段中 HTTP_AUTHORIZATION 获取 #认证信息auth auth = request.META.get(&apos;HTTP_AUTHORIZATION&apos;,None)#处理游客 if auth is None: return None #设置认证字段小规则(两段式):&quot;auth 认证字符串&quot; 在BasicAuthentication类中有规则范式 auth_list = auth.split() #校验是否还是非法用户,不是两段，第一段不是auth就是非法用户 if not (len(auth_list) == 2 and auth_list[0].lower() == &apos;auth&apos;): raise AuthenticationFailed(&apos;认证信息有误，非法用户&apos;) #抛异常 #校验认证信息第二段从auth_list[1]中解析出来 # 注：假设一种情况，信息为abc.123.xyz，就可以解析出admin用户；实际开发，该逻辑一定是校验用户的正常逻辑 if auth_list[1] != &apos;abc.123.xyz&apos;: #校验失败 raise AuthenticationFailed(&apos;信息错误，非法用户&apos;) #最后再去数据库校验是否有此用户 user = models.User.objects.filter(username=&apos;admin&apos;).first() if not user: raise AuthenticationFailed(&apos;用户数据有误，非法用户&apos;) return (user,None) 在settings文件中配置自定义认证组件 123456REST_FRAMEWORK = &#123; # 认证类配置 &apos;DEFAULT_AUTHENTICATION_CLASSES&apos;: [ &apos;utils.authentications.MyAuthentication&apos;, ],&#125; 视图层：views.py 1234567class TestAPIView(APIView): def get(self, request, *args, **kwargs): # 如果通过了认证组件，request.user就一定有值 # 游客：AnonymousUser # 用户：User表中的具体用户对象 print(request.user) return APIResponse(0, &apos;test get ok&apos;) 路由层：urls.py 123urlpatterns = [ url(r&apos;^test/$&apos;, views.TestAPIView.as_view()),] 注意使用Postman请求： 1使用Postman的get请求，在自定义认证组件获取用户，在views视图通过request.user能打印出来 注意配置： 1认证组件一般都是自定义的，不会使用原始的，自定义好需要在settings配置就是全局使用 drf权限组件源码分析 从APIView的dispatch开始 dispatch 方法内 self.initial(request,*args,**kwargs) self.initial(request,*args,**kwargs) 123456789101112131415161718def initial(self, request, *args, **kwargs): &quot;&quot;&quot; Runs anything that needs to occur prior to calling the method handler. &quot;&quot;&quot; self.format_kwarg = self.get_format_suffix(**kwargs) # Perform content negotiation and store the accepted info on the request neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg # Determine the API version, if versioning is in use. version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted self.perform_authentication(request) self.check_permissions(request) #权限组件 self.check_throttles(request) self.check_permissions(request) 权限细节 12345678910def check_permissions(self, request): # 遍历权限对象列表得到一个个权限对象(权限器)，进行权限认证 for permission in self.get_permissions(): # 权限类一定有一个has_permission权限方法，用来做权限认证的 # 参数：权限对象self、请求对象request、视图类对象 # 返回值：有权限返回True，无权限返回False if not permission.has_permission(request, self): self.permission_denied( request, message=getattr(permission, &apos;message&apos;, None) ) self.get_permissions() 获取权限类对象列表 12345def get_permissions(self): &quot;&quot;&quot; Instantiates and returns the list of permissions that this view requires. &quot;&quot;&quot; return [permission() for permission in self.permission_classes] self.permission_classes 获取权限settings源码配置 123DEFAULT_PERMISSION_CLASSES&apos;: [ &apos;rest_framework.permissions.AllowAny&apos;, #所有权限 ] 在源码permissions.py中的系统自带权限类，这里举例四个1234567891011121314151617181920211）AllowAny： 默认是这个权限 认证规则全部返还True：return True 游客与登陆用户都有所有权限2) IsAuthenticated： 常用这个 认证规则必须有登陆的合法用户：return bool(request.user and request.user.is_authenticated) 有登录用户名并且认证成功 游客没有任何权限，登陆用户才有权限 3) IsAdminUser： 认证规则必须是后台管理用户：return bool(request.user and request.user.is_staff) 游客没有任何权限，登陆用户才有权限4) IsAuthenticatedOrReadOnly 认证规则必须是只读请求或是合法用户： return bool( request.method in SAFE_METHODS or request.user and request.user.is_authenticated ) 游客只读，合法用户无限制 1SAFE_METHODS = (&apos;GET&apos;, &apos;HEAD&apos;, &apos;OPTIONS&apos;) 权限组使用：全局使用，局部使用全局使用：默认全局配置的权限类是AllowAny,在settings文件中配置123456REST_FRAMEWORK = &#123; # 权限类配置 &apos;DEFAULT_PERMISSION_CLASSES&apos;: [ &apos;rest_framework.permissions.AllowAny&apos;, #默认所有权限 ],&#125; 局部使用：views.py12345#只有登录后才能访问from rest_framework.permissions import IsAuthenticatedclass TestAuthenticatedAPIView(APIView): permission_classes = [IsAuthenticated] def get(self, request, *args, **kwargs): return APIResponse(0, &apos;test 登录才能访问的接口 ok&apos;) 自定义权限类123456781) 创建继承BasePermission的权限类2) 实现has_permission方法3) 实现体根据权限规则 确定有无权限4) 进行全局或局部配置认证规则i.满足设置的用户条件，代表有权限，返回Trueii.不满足设置的用户条件，代表有权限，返回False utils.permissions.py 1234567891011121314from rest_framework.permissions import BasePermissionfrom django.contrib.auth.models import Groupclass MyPermission(BasePermission): def has_permission(self, request, view): # 只读接口判断 r1 = request.method in (&apos;GET&apos;, &apos;HEAD&apos;, &apos;OPTIONS&apos;) # group为有权限的分组 group = Group.objects.filter(name=&apos;管理员&apos;).first() # groups为当前用户所属的所有分组 groups = request.user.groups.all() r2 = group and groups r3 = group in groups # 读接口大家都有权限，写接口必须为指定分组下的登陆用户 return r1 or (r2 and r3) 视图层：views.py 局部使用自定义的Mypermission来做权限认证 12345678910# 游客只读，登录用户只读，只有登录用户属于 管理员 分组，才可以增删改from utils.permissions import MyPermissionclass TestAdminOrReadOnlyAPIView(APIView): permission_classes = [MyPermission] # 所有用户都可以访问 def get(self, request, *args, **kwargs): return APIResponse(0, &apos;自定义读 OK&apos;) # 必须是 自定义“管理员”分组 下的用户 def post(self, request, *args, **kwargs): return APIResponse(0, &apos;自定义写 OK&apos;) 路由层：urls.py 123urlpatterns = [ url(r&apos;^test3/$&apos;, views.TestAdminOrReadOnlyAPIView.as_view()),] Postman使用get请求：加不加Authorization，都可以读 post请求：不加Authorization，就不能进行写操作，必须要写Authorization]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架 (五)]]></title>
    <url>%2Fposts%2F30ccd969.html</url>
    <content type="text"><![CDATA[复习1.整体修改与局部修改 12345678# 序列化get （给前端传递参数） #查询ser_obj = ModelSerializer(model_obj) #只传递一个参数，默认是instance的参数，查询数据# 反序列化post save() =&gt; create()（数据保存到数据库中） #添加ser_obj = ModelSerializer(data=model_data) #传递data参数，保存数据#反序列化put save() =&gt; update() #修改（需要传入instance和data参数）ser_obj = ModelSerializer(instance=model_obj,data=model_data) #默认partial参数是False,整体修改#反序列化patch partial=True =&gt; 匹配字段required=True校验条件ser_obj = ModelSerializer(instance=model_obj,data=model_data,partial=True) #局部修改 2.群改ListSerializer 12345678910111213141516171819202122ser_obj = ModelSerializer(instance=model_obj,data=model_data,partial=True,many=True) # 实现群改功能，反序列化情况下的create、update就不再调用ModelSerializer的 # 而是调用 ModelSerializer.Meta.list_serializer_class 指向的 ListSerializer 类的create、update # ListSerializer默认只实现了群增的create，要实现群改，必须重写update #自定义序列化类，重写update方法 class MyListSerializer(ListSerializer): def update(self, instance, validated_data): # print(instance) # 要更新的对象们: [obj1, obj2, ...] # print(validated_data) # 更新的对象对应的数据们: [&#123;&#125;, &#123;&#125;, ...] # print(self.child) # 服务的模型序列化类 - V2BookModelSerializer for index, obj in enumerate(instance): self.child.update(obj, validated_data[index]) return instance class MyModelSerializer(ModelSerializer): class Meta: list_serializer_class = MyListSerializer 将两者类建立关联，在MyListSerializer中就可以用self.child拿到MyModelSerializer，进而使用MyModelSerializer中封装好的方法 cls.Meta.list_serializer_class.child = cls 视图类views.py使用context传递参数给序列化类serializers.py12345671）在视图类中实例化序列化对象时，可以设置context内容2）在序列化类中的局部钩子、全局钩子、create、update方法中，都可以用self.context访问视图类传递过来的内容需求：# 1) 在视图类views中，可以通过request得到登陆用户request.user# 2) 在序列化类中，要完成数据库数据的校验与入库操作，可能会需要知道当前的登陆用户，但序列化类无法访问request# 3) 在视图类中实例化序列化对象时，将request对象传递进去 视图层:views.py (使用context传递参数到序列化类中) 12345678910class Book(APIView): def post(self, request, *args, **kwargs): book_ser = serializers.BookModelSerializer(data=request_data,context=&#123;&apos;request&apos;:request&#125;) #视图层context传递参数 book_ser.is_valid(raise_exception=True) book_result = book_ser.save() return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: &apos;ok&apos;, &apos;results&apos;: serializers.BookModelSerializer(book_result).data &#125;) 序列化层：serializers.py 1234567class BookModelSerializer(ModelSerializer): class Meta: model = models.Book fields = (&apos;name&apos;, &apos;price&apos;) def validate_name(self, value): print(self.context.get(&apos;request&apos;).method) #序列化层接收参数 return value 二次封装Response类便于以后每次使用Response自定义APIResponse 1234567891011121314151617181920from rest_framework.response import Responseclass APIResponse(Response): def __init__(self, data_status=0, data_msg=&apos;ok&apos;, results=None, http_status=None, headers=None, exception=False, **kwargs): # data的初始状态：状态码与状态信息 data = &#123; &apos;status&apos;: data_status, &apos;msg&apos;: data_msg, &#125; # data的响应数据体 # results可能是False、0等数据，这些数据某些情况下也会作为合法数据返回 if results is not None: data[&apos;results&apos;] = results # data响应的其他内容 # if kwargs is not None: # for k, v in kwargs.items(): # setattr(data, k, v) data.update(kwargs) super().__init__(data=data, status=http_status, headers=headers, exception=exception) #重写父类Response的__init__方法 视图家族12345678views：视图generics：工具视图mixins：视图工具集viewsets：视图集学习曲线APIView =&gt; GenericAPIView =&gt; mixins的五大工具类 =&gt; generics中的工具视图 =&gt; viewsets中的视图集 两个视图基类 APIView和GenericAPIView1. AIPView123456789101112131415from rest_framework.views import APIViewAPIView是REST framework提供的所有视图的基类，继承自Django的View父类。APIView与View的不同之处在于：1.传入到视图方法中的是REST framework的Request对象，而不是Django的HttpRequeset对象；2.视图方法可以返回REST framework的Response对象，视图会为响应数据设置（render）符合前端要求的格式；3.任何APIException异常都会被捕获到，并且处理成合适的响应信息；4.在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制。支持定义的属性：authentication_classes 列表或元祖，身份认证类permissoin_classes 列表或元祖，权限检查类throttle_classes 列表或元祖，流量控制类 在APIView中仍有get(),post()等其他请求方式的方法 123456789from rest_framework.views import APIViewfrom rest_framework.response import Response # url(r&apos;^books/$&apos;, views.BookListView.as_view()),class BookListView(APIView): def get(self, request): books = BookInfo.objects.all() serializer = BookInfoSerializer(books, many=True) return Response(serializer.data) 2. GenericAPIView通用视图类12345GenericAPIView是继承APIView的，使用完全兼容APIView，主要增加了操作序列化器和数据库查询的方法，作用是为下面Mixin扩展类的执行提供方法支持。通常在使用时，可以配合一个或多个Mixin扩展类重点：GenericAPIView在APIView基础上完成了哪些事 1）get_queryset()：从类属性queryset中获得model的queryset数据 群操作就走get_queryset()方法(包括群查，群增等) 2）get_object()：从类属性queryset中获得model的queryset数据，再通过有名分组pk确定唯一操作对象 单操作就走get_object()方法（包括单查，单增等） 3）get_serializer()：从类属性serializer_class中获得serializer的序列化类 支持的属性： 列表视图与详情视图通过： （重点**） queryset 指明视图需要的数据（model查询数据） serializer_class 指明视图使用的序列化器 列表视图使用： pagination_class 分页控制类 filter_backends 过滤控制后端 详情页视图使用： lookup_field 自定义主键 有名分组的查询，默认是’pk’ lookup_url_kwarg 查询单一数据时url中的参数关键字名称，默认与look_field相同 提供的方法：(\****)** 1.get_queryset() 从类属性queryset中获得model的queryset数据 2.get_object() 从类属性queryset中获得model的queryset数据，再通过有名分组pk来确定唯一操作对象。 3.get_serializer() 从类属性serializer_class中获得serializer的序列化类，主要用来提供给Mixin扩展类使用。 get_serializer源码： 举例： 视图层：views.py 123456789101112131415161718from rest_framework.generics import GenericAPIViewclass BookGenericAPIView(GenericAPIView): queryset = models.Book.objects.filter(is_delete=False) serializer_class = serializers.BookModelSerializer lookup_field = &apos;pk&apos; #先定义好，单查可以使用，默认是pk 自定义主键的有名分组，如果路由有名分组不是pk,这个属性就要自己设置了 # 群取 def get(self, request, *args, **kwargs): book_query = self.get_queryset() #获取queryset数据（model查询数据） book_ser = self.get_serializer(book_query, many=True) book_data = book_ser.data return APIResponse(results=book_data) # 单取 def get(self, request, *args, **kwargs): book_query = self.get_object() book_ser = self.get_serializer(book_query) book_data = book_ser.data return APIResponse(results=book_data) 路由层：urls.py 1234urlpatterns = [ url(r&apos;^v2/books/$&apos;, views.BookGenericAPIView.as_view()), url(r&apos;^v2/books/(?P&lt;pk&gt;.*)/$&apos;, views.BookGenericAPIView.as_view()),] 五个视图扩展类 mixins视图工具集-辅助GenericAPIView作用：提供了几种后端视图（对数据资源的增删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。 1231）mixins有五个工具类文件，一共提供了五个工具类，六个工具方法：单查、群查、单增、单删、单整体改、单局部改2）继承工具类可以简化请求函数的实现体，但是必须继承GenericAPIView，需要GenericAPIView类提供序列化器与数据库查询的方法(见上方GenericAPIView基类知识点)3）工具类的工具方法返回值都是Response类型对象，如果要格式化数据格式再返回给前台，可以通过 response.data 拿到工具方法返回的Response类型对象的响应数据 五个工具类：CreateModelMixin（增加）,DestroyModelMixin（删除）,ListModelMixin（查询,查queryset）,RetrieveModelMixin（查询，查对象，针对于存在”pk”）,UpdateModelMixin（修改） 1.ListModelMixin（群查） 列表视图扩展类，提供 list 方法快速实现查询视图，返回200状态码。除了查询，该list方法会对数据进行过滤和分页 2.CreateModelMixin（单增） #注意：没有群增的方法，需要自己手动写（\****）** 创建视图扩展类，提供create方法快速创建资源的视图，成功返回201的状态码 3.RetrieveModelMixin(单查) 详情视图扩展类，提供retrieve方法，可以快速实现返回一个存在的数据对象。 4.UpdateModelMixin(更新，修改) #只有单整体改和单局部改，没有群整体改和群局部改 更新视图扩展类，提供update方法，可以快速实现更新一个存在的数据对象，同时也提供partial_update方法，可以实现局部更新。 5.DestoryModelMixin(删除) 一般不怎么用到 删除视图扩展类，提供destory方法，可以快速实现删除一个存在数据对象。 代码示例： 视图层：views.py 123456789101112131415161718192021222324252627from rest_framework.mixins import ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixinclass BookMixinGenericAPIView(ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericAPIView): #GenericAPIView提供的序列化器和查询的数据 queryset = models.Book.objects.filter(is_delete=False) serializer_class = serializers.BookModelSerializer #单查和群查 def get(self, request, *args, **kwargs): if &apos;pk&apos; in kwargs: response = self.retrieve(request, *args, **kwargs) #单查 RetrieveModelMixin方法 else: # mixins提供的list方法的响应对象是Response，将该对象格式化为自定义的APIResponse response = self.list(request, *args, **kwargs) #群查 ListModelMixin # response的数据都存放在response.data中 return APIResponse(results=response.data) #单增 def post(self, request, *args, **kwargs): response = self.create(request, *args, **kwargs) #CreateModelMixin方法 return APIResponse(results=response.data) #单整体修改 def put(self, request, *args, **kwargs): response = self.update(request, *args, **kwargs) #UpdateModelMixin return APIResponse(results=response.data) #单局部修改 def patch(self, request, *args, **kwargs): response = self.partial_update(request, *args, **kwargs) return APIResponse(results=response.data) 路由层：urls.py 1234urlpatterns = [ url(r&apos;^v3/books/$&apos;, views.BookMixinGenericAPIView.as_view()), url(r&apos;^v3/books/(?P&lt;pk&gt;.*)/$&apos;, views.BookMixinGenericAPIView.as_view()),] 常用功能子类视图 工具视图(继承了GenericAPIView和各种Mixins工具类)121）工具视图都是GenericAPIView的子类，且不同的子类继承了不同的工具类2）工具视图的功能可以满足需求，只需要继承工具视图，并且提供queryset与serializer_class即可 视图 作用 可使用方法 父类 ListAPIView 查询多条数据 get GenericAPIView ListModelMixin CreateAPIView 新增一条数据 post GenericAPIView CreateModelMixin RetrieveAPIView 查询一条数据 get GenericAPIView RetrieveModelMixin UpdateAPIView 修改一条数据 put，patch GenericAPIView UpdateModelMixin DestroyAPIView 删除一条数据 delete GenericAPIView DestroyModelMixin RetrieveUpdateAPIView 单查，更新一条数据 get，put，patch GenericAPIView RetrieveModelMixin UpdateModelMixin RetrieveUpdateDestroyAPIView 单查，更新，删除一条数据 get，put，patch，delete GenericAPIView RetrieveModelMixin UpdateModelMixin DestroyModelMixin ListCreateAPIView 群查，更新一条 get,post GenericAPIView CreateModelMixin ListModelMixin 视图层：views.py 1234from rest_framework.generics import ListCreateAPIView, UpdateAPIViewclass BookListCreatePIView(ListCreateAPIView, UpdateAPIView): queryset = models.Book.objects.filter(is_delete=False) serializer_class = serializers.BookModelSerializer 路由层：urls.py 1234urlpatterns = [ url(r&apos;^v4/books/$&apos;, views.BookListCreatePIView.as_view()), url(r&apos;^v4/books/(?P&lt;pk&gt;.*)/$&apos;, views.BookListCreatePIView.as_view()),] 视图集 viewsetmixin （注意路由设置）12345678910111.常用视图集父类 ViewSet 继承自APIView和ViewSetMixin,没有提供任何方法，需要自己写 GenericViewSet 继承GenericAPIView和ViewSetMixin,其中GenericAPIView提供了基础方法，可以直接搭配Mixin扩展类使用，所以我们选这个 ModelViewSet 继承GenericViewset,但同时也包括ListModelMixin、CreateModelMixin等mixin扩展类1）视图集都是默认优先继承ViewSetMixin类，再继承一个视图类（GenericAPIView或APIView） 2）ViewSetMixin提供了重写的as_view()方法，继承视图集的视图类，配置路由时调用as_view()必须传入 请求名-函数名 映射关系字典 eg: url(r&apos;^v5/books/$&apos;, views.BookGenericViewSet.as_view(&#123;&apos;get&apos;: &apos;my_get_list&apos;&#125;)), 表示get请求会交给my_get_list视图函数处理 路由层：urls.py 123456urlpatterns = [ # View的as_view()：将get请求映射到视图类的get方法 # ViewSet的as_view(&#123;&apos;get&apos;: &apos;my_get_list&apos;&#125;)：将get请求映射到视图类的my_get_list方法 url(r&apos;^v5/books/$&apos;, views.BookGenericViewSet.as_view(&#123;&apos;get&apos;: &apos;my_get_list&apos;&#125;)), url(r&apos;^v5/books/(?P&lt;pk&gt;.*)/$&apos;, views.BookGenericViewSet.as_view(&#123;&apos;get&apos;: &apos;my_get_obj&apos;&#125;)),] 视图层：views.py 1234567891011from rest_framework.viewsets import GenericViewSetfrom rest_framework import mixins #工具集 可以使用list,retrieve等方法class BookGenericViewSet(mixins.RetrieveModelMixin, mixins.ListModelMixin, GenericViewSet): queryset = models.Book.objects.filter(is_delete=False) serializer_class = serializers.BookModelSerializer def my_get_list(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def my_get_obj(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) GenericAPIView与APIView两大继承视图的区别 1234561）GenericViewSet和ViewSet都继承了ViewSetMixin，as_view都可以配置 请求-函数 映射2）GenericViewSet继承的是GenericAPIView视图类，用来完成标准的 model 类操作接口3）ViewSet继承的是APIView视图类，用来完成不需要 model 类参与，或是非标准的 model 类操作接口 post请求在标准的 model 类操作下就是新增接口，登陆的post不满足 post请求验证码的接口，不需要 model 类的参与案例：登陆的post请求，并不是完成数据的新增，只是用post提交数据，得到的结果也不是登陆的用户信息，而是登陆的认证信息 工具视图集 （工具集和视图集的混合使用）路由层：urls.py 1234urlpatterns = [ url(r&apos;^v6/books/$&apos;, views.BookModelViewSet.as_view(&#123;&apos;get&apos;: &apos;list&apos;, &apos;post&apos;: &apos;create&apos;&#125;)), url(r&apos;^v6/books/(?P&lt;pk&gt;.*)/$&apos;, views.BookModelViewSet.as_view(&#123;&apos;get&apos;: &apos;retrieve&apos;, &apos;put&apos;: &apos;update&apos;, &apos;patch&apos;: &apos;partial_update&apos;, &apos;delete&apos;: &apos;destroy&apos;&#125;)),] 视图层：views.py 12345678910111213from rest_framework.viewsets import ModelViewSetclass BookModelViewSet(ModelViewSet): queryset = models.Book.objects.filter(is_delete=False) serializer_class = serializers.BookModelSerializer # 删不是数据库，而是该记录中的删除字段 def destroy(self, request, *args, **kwargs): instance = self.get_object() # type: models.Book if not instance: return APIResponse(1, &apos;删除失败&apos;) # 实际操作，在此之前就做了判断 instance.is_delete = True instance.save() return APIResponse(0, &apos;删除成功&apos;) 路由组件（了解）123456789101112from django.conf.urls import includefrom rest_framework.routers import SimpleRouterrouter = SimpleRouter()# 所有路由与ViewSet视图类的都可以注册，会产生 &apos;^v6/books/$&apos; 和 &apos;^v6/books/(?P&lt;pk&gt;[^/.]+)/$&apos;router.register(&apos;v6/books&apos;, views.BookModelViewSet)urlpatterns = [ # 第一种添加子列表方式 url(r&apos;^&apos;, include(router.urls)),]# 第二种添加子列表方式# urlpatterns.extend(router.urls)]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架 (四)]]></title>
    <url>%2Fposts%2F36678e14.html</url>
    <content type="text"><![CDATA[单整体改 单指的是单独一条数据，整体指这条数据的设置不为空字段都必须传值修改基于上篇文章的代码修改，序列化层不用变，只修改views.py 1234567891011121314151617181)单整体改，说明前台要提供修改的数据，修改之后保存的数据需要校验，校验的数据应该在实例化“序列化类对象”时，赋值给data2）修改，就必须明确被修改的模型类对象，并在实例化“序列化类对象”时，赋值给instance，必须赋值给instance3）整体修改，所有校验规则有required=True的字段，都必须提供，因为在实例化“序列化类对象”时，参数partial默认为False注：如果partial值设置为True，就是可以局部改1）单整体修改，一般用put请求：V2BookModelSerializer( instance=要被更新的对象, data=用来更新的数据, partial=默认False，必须的字段全部参与校验)2）单局部修改，一般用patch请求：V2BookModelSerializer( instance=要被更新的对象, data=用来更新的数据, partial=设置True，必须的字段都变为选填字段) 注：partial设置True的本质就是使字段 required=True 校验规则失效 123请求方法：put 整体修改请求参数：pk从路由传参，修改的数据通过数据包json传递请求接口： http://127.0.0.1:8080/app01/v3/books/pk/ 视图层：views.py 1234567891011121314151617181920212223#单整体改 对 v3/books/pk/ 传的参数是与model对应的字典 &#123;name|price|publish|authors&#125;在json中传递class V3Book(APIView): def put(self,request,*args,**kwargs): request_data = request.data pk = kwargs.get(&apos;pk&apos;) #先获取要修改的对象 try: old_book_obj = models.Book.objects.get(pk=pk,is_delete=False) except: #当输入不存在的pk return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;参数错误&apos; &#125;) book_ser = serializers.V2BookModelSerializer(instance=old_book_obj,data=request_data,partial=False) book_ser.is_valid(raise_exception=True) book_obj = book_ser.save() return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:serializers.V2BookModelSerializer(book_obj).data &#125;) 单整体修改注意点（**） 1231.需要修改的数据通过data传递2.需要修改的模型类对象必须传递给instance3.参数partial设置为False (默认是False,这里不设置也行) 单局部修改单整体修改和单局部修改只有一点不相同： 1设置参数partial=True，就变成单局部修改，修改的参数就不必全部传，想修改什么数据就传什么数据 单局部修改和群局部修改整合 ListSerializer辅助（群增，群改）123当一个序列化器在带有many=True选项被序列化时，将创建一个ListSerializer实例，该序列化器类将成为ListSerializer类的子类。当你需要自定义多个对象的行为时（比如群增，群改）,你需要手动定制ListSerializer类的一些行为。可以通过在自定义序列化器的Meta类下面的list_serializer_class来绑定你需要的的ListSerializer类 序列化层 serializer.py 群改需要设置ListSerializer，创建V2BookListSerializer继承ListSerializer,重写update方法 1234567891011121314# 重点：ListSerializer与ModelSerializer建立关联的是： 在ModelSerializer的Meta类中设置 list_serializer_classclass V2BookListSerializer(ListSerializer): def update(self, instance, validated_data): # print(instance) # 要更新的对象们 # print(validated_data) # 更新的对象对应的数据们 # print(self.child) # 服务的模型序列化类 - V2BookModelSerializer for index, obj in enumerate(instance): self.child.update(obj, validated_data[index]) return instance # 原模型序列化类变化class V2BookModelSerializer(ModelSerializer): class Meta: # 群改，list_serializer_class是固定的key写法，直接转入V2BookListSerializer类的 update 方法 list_serializer_class = V2BookListSerializer update方法源码分析： update方法里面没写东西 群增不需要重写create方法，因为源码中ListSerializer走的就是ModelSerializer的create方法 create方法源码分析： 群局部修改 12345请求方式：patch请求参数： 单局部修改： v3/books/pk/ pk通过路由传参，修改数据通过json传参 群局部修改： v3/books/ 修改的数据都是从json传递 eg:[&#123;&apos;pk&apos;:1,&apos;name&apos;:&apos;花果山&apos;&#125;，&#123;&apos;pk&apos;:2,&apos;price&apos;:3.33&#125;]请求接口：http://127.0.0.1:8080/app01/v3/books/pk/ 视图层:views.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#单局部改和群局部改整合 #单局部改：对 v3/books/pk/ pk通过路由传参，修改数据选择传参，通过数据包json传递 #群局部修改：v3/books/ 修改数据通过数据包传递，设置成列表格式 [&#123;pk:1,name:123&#125;,&#123;pk:3,price:7&#125;,&#123;pk:7,publish:2&#125;] def patch(self,request,*args,**kwargs): request_data = request.data #数据包数据 pk = kwargs.get(&apos;pk&apos;) # 将单改，群改的数据都格式化成 pks=[要需要的对象主键标识] | request_data=[每个要修改的对象对应的修改数据] if pk and isinstance(request_data,dict): #单改 pks = [pk,] request_data = [request_data,] elif not pk and isinstance(request_data,list): #群改 pks = [] # 遍历前台数据[&#123;pk:1, name:123&#125;, &#123;pk:3, price:7&#125;, &#123;pk:7, publish:2&#125;]，拿一个个字典 for dic in request_data: pk=dic.pop(&apos;pk&apos;,None) #返回pk值 if pk: pks.append(pk) #pk没有传值 else: return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;参数错误&apos; &#125;) else: return Response(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;参数错误&apos; &#125;) # pks与request_data数据筛选， # 1）将pks中的没有对应数据的pk与数据已删除的pk移除，request_data对应索引位上的数据也移除 # 2）将合理的pks转换为 objs objs = [] new_request_data = [] for index,pk in enumerate(pks): try: #将pk合理的对象数据保存下来 book_obj = models.Book.objects.get(pk=pk,is_delete=False) objs.append(book_obj) #对应索引的数据也保存下来 new_request_data.append(request_data[index]) except: # 重点：反面教程 - pk对应的数据有误，将对应索引的data中request_data中移除 #在for循环中不要使用删除 # index = pks.index(pk) # request_data.pop(index) continue #生成一个serializer对象 book_ser = serializers.V2BookModelSerializer(instance=objs,data=new_request_data,partial=True,many=True) book_ser.is_valid(raise_exception=True) book_objs = book_ser.save() return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:serializers.V2BookModelSerializer(book_objs,many=True).data &#125;) 思路： 12341.先将单改，群改的数据都格式化成 pks=[要需要的对象主键标识] | request_data=[每个要修改的对象对应的修改数据]2.pks与request_data数据筛选， 将pks中的没有对应数据的pk与数据已删除的pk移除，request_data对应索引位上的数据也移除 将合理的pks转换为 objs 注意点： 121.本篇文章讲了局部修改patch,和整体修改put,都需要设置参数instance传入的是要修改的对象，data传入的是修改的数据2.群修改的话需要使用ListSerializer,重写update方法 关于使用修改为什么要用instance传参 （源码分析）修改之后数据使用save()保存，从视图的save()点击进去查看源码，下面是BaseSerializer类中的save 在这判断是否有instance属性 有的话就走update()方法，所以我们在做修改（put,patch）的时候就要传入instance。 没有的话就走create(),创建一条新数据 源码中发现：如果你使用的是Serializer,在视图使用save方法保存数据，但是通过源码发现Serializer类中没有save方法所以只能从他继承的BaseSerializer中走save方法。你使用的是ModelSerializer,因为ModelSerializer类中没有save方法，只能去他继承的Serializer类中找save方法，Serializer类中也没有save方法，所以最后不管你用的是Serializer还是ModelSerializer都要去BaseSerializer中找save方法。然后从save方法中去实现update和create方法。 拓展： 顺带提一嘴，在BaseSerializer中的update和create方法都是不起作用的，从下面源码可以看出，所以如果你的Serializer类是走的BaseSerializer的update和create方法，那么你就必须在你的Serializer类中重写update和create方法 因为ModelSeerializer中有create和update方法，而且都是有用的，所以在ModelSeerializer中不需要重写create和update方法]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架（三）]]></title>
    <url>%2Fposts%2Fb6a7d53b.html</url>
    <content type="text"><![CDATA[media资源路径设置 （设置好后把图片放在这个文件夹中，通过链接能访问到图片）1.先在根目录设置一个media文件夹 2.配置settings.py,加上下面的 12MEDIA_URL = &apos;/media/&apos;MEDIA_ROOT = os.path.join(BASE_DIR, &apos;media&apos;) 3.在urls.py路由设置 123456from django.views.static import servefrom django.conf import settingsurlpatterns = [ url(r&apos;^media/(?P&lt;path&gt;.*)&apos;, serve, &#123;&apos;document_root&apos;: settings.MEDIA_ROOT&#125;),] 多表设计12345678BaseModel基表 is_delete、create_time下面四表继承基表，可以继承两个字段Book表：name、price、img、authors、publish、is_delete、create_timePublish表：name、address、is_delete、create_time Author表：name、age、is_delete、create_timeAuthorDetail表：mobile, author、is_delete、create_time 基表设置 （注意设置abstract = True）1234567class BaseModel(models.Model): is_delete = models.BooleanField(default=False) create_time = models.DateTimeField(auto_now_add=True) # 设置 abstract = True 来声明基表，作为基表的Model不能在数据库中形成对应的表 class Meta: abstract = True 断关联多表关系 （\****）** db_constraint=False （设置了这个就是断关联，设置在外键，删除了作者详情，也不会删除作者）123456789101112131415161718192021222324252627282930313233343536373839401、外键位置： 一对多 - 外键放多的一方 一对一 - 从逻辑正反向考虑，如作者表与作者详情表，作者删除级联作者详情也删除，详情删除作者依旧存在，所以建议外键在详情表中 （和之前的一对一关系外键放置不一样，之前都是把外键放在查询频率高的表） 多对多 - 外键在关系表中 2、ORM正向方向连表查找： 正向：通过外键字段 eg: author_detial_obj.author #外键设置在作者详情表，在作者详情表中查询作者直接.author就可以 反向：通过设置反向查询related_name的值 eg：author_obj.detail #外键没有设置在作者表中，在作者表中通过设置反向查询.detail查询作者详情 注：依赖代码见下方 3、连表操作关系：（外键建在作者详情表中） 1）作者删除，详情级联 - on_delete=models.CASCADE #跟着一起删除 2）作者删除，详情置空 - null=True, on_delete=models.SET_NULL #外键字段清空 3）作者删除，详情重置 - default=0, on_delete=models.SET_DEFAULT 4）作者删除，详情不动 - on_delete=models.DO_NOTHING 注：拿作者与作者详情表举例 4、外键关联字段的参数 - 如何实现断关联、目前表间操作关系、方向查询字段 i）作者详情表中的（外键设置在作者详情表中） author = models.OneToOneField( to=&apos;Author&apos;, #和作者表关联 related_name=&apos;detail&apos;, #反查询，作者表直接查作者详情表的电话号码，可以直接author_obj.detail.mobile db_constraint=False, #断关联 on_delete=models.CASCADE #级联删除 ) ii）图书表中的 publish = models.ForeignKey( to=&apos;Publish&apos;, related_name=&apos;books&apos;, db_constraint=False, on_delete=models.DO_NOTHING, ) authors = models.ManyToManyField( to=&apos;Author&apos; related_name=&apos;books&apos;, db_constraint=False, ) 注：ManyToManyField不能设置on_delete，OneToOneField、ForeignKey必须设置on_delete（django1.x系统默认级联，但是django2.x必须手动明确） models.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from django.db import models#基类class BaseModel(models.Model): is_delete = models.BooleanField(default=False) #默认不是删除，数据库中是0/1 create_time = models.DateTimeField(auto_now_add=True) # 设置 abstract = True 来声明基表，作为基表的Model不能在数据库中形成对应的表 class Meta: abstract = True #声明该表只是一个抽象表不出现在数据库中#书籍表class Book(BaseModel): name = models.CharField(max_length=64) price = models.DecimalField(max_digits=5,decimal_places=2) img = models.ImageField(upload_to=&apos;img&apos;,default=&apos;default.jpg&apos;) #关联出版社表 publish = models.ForeignKey( to=&apos;Publish&apos;, #关联publish表 db_constraint=False, #断关联（断开Book表和Publish表的关联,方便删数据,虽然断开了关联但是还能正常使用） related_name=&apos;books&apos;,#反向查询字段：publish_obj.books就能查出当前出版社出版的的所有书籍 on_delete=models.DO_NOTHING,#设置连表操作关系 ) #关联作者表 authors = models.ManyToManyField( to=&apos;Author&apos;, db_constraint=True, #断开关联 related_name=&apos;books&apos; #反向查询字段 ) class Meta: db_table=&apos;book&apos; verbose_name=&apos;书籍&apos; verbose_name_plural=verbose_name def __str__(self): return self.name#出版社表class Publish(BaseModel): &quot;&quot;&quot;name、address、is_delete、create_time&quot;&quot;&quot; name = models.CharField(max_length=64) addres = models.CharField(max_length=64) class Meta: db_table=&apos;publish&apos; verbose_name=&apos;出版社&apos; verbose_name_plural=verbose_name def __str__(self): return self.name#作者表class Author(BaseModel): &quot;&quot;&quot;name、age、is_delete、create_time&quot;&quot;&quot; name = models.CharField(max_length=64) age = models.IntegerField() class Meta: db_table = &apos;author&apos; verbose_name=&apos;作者&apos; verbose_name_plural=verbose_name def __str__(self): return self.name#作者详情class AuthorDetail(BaseModel): &quot;&quot;&quot;mobile, author、is_delete、create_time&quot;&quot;&quot; mobile = models.CharField(max_length=11) author = models.OneToOneField( to=&apos;Author&apos;, db_constraint=False, related_name=&apos;detail&apos;, on_delete=models.CASCADE ) class Meta: db_table=&apos;author_detail&apos; verbose_name=&apos;作者详情&apos; verbose_name_plural=verbose_name def __str__(self): return self.author.name 序列化 ModelSerializer 模型类序列化器ModelSerializer与常规的Serializer相同，但提供了： 1.基于模型类自动生成一系列字段 2.包含默认的create()和update()的实现 3.基于模型类自动为Serializer生成validators,比如unique_together 序列化层：api/serializers.py 简单的写 123456789101112131415from rest_framework.serializers import ModelSerializer,SerializerMethodFieldfrom . import models#publish接口的序列化class PublishModelSerializers(ModelSerializer): class Me= (&apos;name&apos;,&apos;address&apos;) #选择需要序列化的字段，前端只显示这些字段（指明模型类的哪些字段生成）#Book接口序列化class BookModelSerializers(ModelSerializer): #了解：1.还可以自定义设置序列化字段，但是必须在fields中声明,在fields中写publish_address publish_address = SerializerMethodField() def get_publish_address(self,obj) return obj.publish.address #2.自定义连表深度-子序列化方式-该方式不能参与反序列化，使用在序列化和反序列化共存时，不能书写(******) publish = 在models.py中Book类设置publish_name和author_list属性方法 (插拔式获取) 12345678#序列化插拔式属性 -完成自定义字段名完成连表查询 @property def publish_name(self): #自定义查询出版社名字 return self.publish.name @property def author_list(self): return self.authors.values(&apos;name&apos;,&apos;age&apos;) 视图层 :views.py 123456789101112131415161718192021222324252627from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom . import models,serializersclass Book(APIView): def get(self,request,*args,**kwargs): pk = kwargs.get(&apos;pk&apos;) #单查 if pk: try: book_obj = models.Book.objects.filter(pk=pk,is_delete=False) book_data = serializers.BookModelSerializers(book_obj).data #单条数据序列化 except: return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;数据不存在&apos; &#125;) #群查 else: book_query = models.Book.objects.filter(is_delete=False).all() #先筛选查询,再查所有 book_data = serializers.BookModelSerializers(book_query,many=True).data #不管是一条还是多条，只要数据是被[]嵌套，都要写many=True #返回前端数据 return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:book_data &#125;) 路由层：api/urls.py 1234urlpatterns = [ url(r&apos;^books/$&apos;, views.Book.as_view()), url(r&apos;^books/(?P&lt;pk&gt;.*)/$&apos;, views.Book.as_view()),] 反序列化序列化层：api/serializers.py 123456789101112131415161718192021222324252627282930313233class BookModelDeserializer(ModelSerializer): #一些只参与反序列化的字段，但是不是与数据库关联的，自定义不入库的反序列化的字段 re_name = seializers.CharField(write_only=True) class Meta: model = models.Book fields = (&apos;name&apos;, &apos;price&apos;, &apos;publish&apos;, &apos;authors&apos;) #没有默认值的字段必须序列化，为其传值 # extra_kwargs 用来完成反序列化字段的 系统校验规则 extra_kwargs = &#123; &apos;name&apos;: &#123; &apos;required&apos;: True, #设置name字段必填 &apos;min_length&apos;: 1, &apos;error_messages&apos;: &#123; &apos;required&apos;: &apos;必填项&apos;, &apos;min_length&apos;: &apos;太短&apos;, &#125; &#125; &#125; # 局部钩子校验单个字段 validate_字段名 def validate_name(self, value): #value是字段name的值 # 书名不能包含 g 字符 if &apos;g&apos; in value.lower(): raise ValidationError(&apos;该g书不能出版&apos;) return value # 全局钩子 def validate(self, attrs): publish = attrs.get(&apos;publish&apos;) #publish如果是外键字段，这个就是publish对象 name = attrs.get(&apos;name&apos;) if models.Book.objects.filter(name=name, publish=publish): raise ValidationError(&#123;&apos;book&apos;: &apos;该书已存在&apos;&#125;) return attrs # 注意：ModelSerializer类已经帮我们实现了 create 与 update 方法,不需要写create就能创建 视图层：views.py 1234567891011def post(self,request,*args,**kwargs): request_data = request.data #获取post提交的数据包 book_ser = serializers.BookModelDeserializer(data=request_data) # raise_exception=True：当校验失败，马上终止当前视图方法，抛异常返回给前台 book_ser.is_valid(raise_exception=True) #检验是否合格 raise_exception=True必填的 book_obj = book_ser.save() #保存得到一个对象 return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:serializers.BookModelSerializers(book_obj).data &#125;) 路由层：urls.py 在postman中访问路径时最后必须带上/,post请求方式只有json格式能一个字段提交多个值,放在列表或者元组中，其余两个只能传递单个值 1234urlpatterns = [ url(r&apos;^books/$&apos;, views.Book.as_view()), url(r&apos;^books/(?P&lt;pk&gt;.*)/$&apos;, views.Book.as_view()),] 注意：（\****）** 1234567891011反序列化层：1.在设置fields，没有默认值的字段都必须设置反序列化保存到数据库中2.使用extra_kwargs 来设置系统校验规则3.设置局部钩子和全局钩子4.ModelSerializer类已经帮我们实现了 create 与 update 方法，不需要再写视图层：1.POST请求通过request.data拿到数据包2.传给反序列化 ,通过data=request_data传入需要反序列化的数据3.is_valid判断校验是否合格 ，raise_exception=True必须要写的4.通过.save()保存到数据库中 序列化与反序列化整合（**）序列化层：api/serializers.py 123456789101112131415161718192021222324252627282930313233343536373839404142class V2BookModelSerializer(ModelSerializer): class Meta: model = models.Book fields = (&apos;name&apos;, &apos;price&apos;, &apos;img&apos;, &apos;author_list&apos;, &apos;publish_name&apos;, &apos;publish&apos;, &apos;authors&apos;) extra_kwargs = &#123; &apos;name&apos;: &#123; &apos;required&apos;: True, &apos;min_length&apos;: 1, &apos;error_messages&apos;: &#123; &apos;required&apos;: &apos;必填项&apos;, &apos;min_length&apos;: &apos;太短&apos;, &#125; &#125;, &apos;publish&apos;: &#123; &apos;write_only&apos;: True &#125;, &apos;authors&apos;: &#123; &apos;write_only&apos;: True &#125;, &apos;img&apos;: &#123; &apos;read_only&apos;: True, &#125;, &apos;author_list&apos;: &#123; &apos;read_only&apos;: True, &#125;, &apos;publish_name&apos;: &#123; &apos;read_only&apos;: True, &#125; &#125; def validate_name(self, value): # 书名不能包含 g 字符 if &apos;g&apos; in value.lower(): raise ValidationError(&apos;该g书不能出版&apos;) return value def validate(self, attrs): publish = attrs.get(&apos;publish&apos;) name = attrs.get(&apos;name&apos;) if models.Book.objects.filter(name=name, publish=publish): raise ValidationError(&#123;&apos;book&apos;: &apos;该书已存在&apos;&#125;) return attrs 序列化层注意点： 12345671) fields中设置所有序列化与反序列化字段2) extra_kwargs划分只序列化或只反序列化字段（一般我们把需要存入到数据库中的使用write_only（反序列化）,只需要展示的就read_only(序列化)，看需求设计） write_only：只反序列化 read_only：只序列化 自定义字段默认只序列化(read_only) 如果字段没设置write_only或者read_only，那么该字段可以序列化和反序列化3) 设置反序列化所需的 系统、局部钩子、全局钩子 等校验规则 视图层：views.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class V2Book(APIView): def get(self,request,*args,**kwargs): pk = kwargs.get(&apos;pk&apos;) #单查 if pk: try: book_obj = models.Book.objects.get(pk=pk,is_delete=False) book_data = serializers.V2BookModelSerializer(book_obj).data #序列化 except: return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;参数有误&apos; &#125;) #群查 else: book_query=models.Book.objects.filter(is_delete=False).all() book_data = serializers.V2BookModelSerializer(book_query,many=True).data #序列化 return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:book_data &#125;) def post(self,request,*args,**kwargs): #单增:传的数据是与model对应的一个字典 # 群增：设计传递的是多个model对应的字典列表,在postman中通过列表嵌套字典传值 request_data = request.data if isinstance(request_data,dict): #判断获取的数据是否是dict many = False elif isinstance(request_data,list): #判断获取的数据是否是list many = True else: return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;数据错误&apos; &#125;) book_ser = serializers.V2BookModelSerializer(data=request_data,many=many) #反序列化 book_ser.is_valid(raise_exception=True) book_result = book_ser.save() #book_result是对象&lt;class &apos;app01.models.Book&apos;&gt;，群增就是列表套一个个对象 return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:serializers.V2BookModelSerializer(book_result,many=many).data &#125;) #单删: 有pk #在postman中通过路径传参 #群删：有pks &#123;&quot;pks&quot;: [1, 2, 3]&#125; #通过json传参 def delete(self,request,*args,**kwargs): pk = kwargs.get(&apos;pk&apos;) if pk: pks = [pk] else: pks = request.data.get(&apos;pks&apos;) if models.Book.objects.filter(pk__in=pks,is_delete=False).update(is_delete=True): return Response(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;删除成功&apos; &#125;) return Response(&#123; &apos;status&apos;:1, &apos;msg&apos;:&apos;删除失败&apos; &#125;) 视图层注意点：(\**)** 1231.序列化数据最后必须要.data （因为要传给前端）2.反序列化通过data传参，序列化通过instance传参（当你只传一个参数时，默认是instanca的参数）3.反序列化与序列化都能使用many=True，序列化和反序列化数据只要被[]嵌套都要写many=True 路由层：urls.py 1234urlpatterns = [ url(r&apos;^v2/books/$&apos;, views.V2Book.as_view()), url(r&apos;^v2/books/(?P&lt;pk&gt;.*)/$&apos;, views.V2Book.as_view()),] instance/data/many/partial四个关键参数的用法总结 123456789101112instance/data/many/partial 影响序列化对象行为的四个关键参数。序列化情况：1.如果没有data参数，只有instance，那么就不存在反序列化校验一说，只有序列化对象instance。反序列化情况：2.如果有data，没有instance，那么需要进行校验data，然后将data进行反序列化，得到validated_data,此时再通过序列化对象获取data，这个data和初始化提供的data可不一样，这个序列化validated_data后的data，比起初始化data，可能减少了无效的字段（序列化没有定义的字段）。修改情况：3.如果又提供了instance 又提供了data, 那么只要有data或者部分data，那么data都要进行验证才能进行下面的save等操作，如果不经过is_valid过程，那么后面的获取序列化数据或者反序列化数据都会无效。ListSerializer使用情况：4.many参数将直接影响序列化类的类型，如果是many=False，那么直接使用当前序列化类。如果many=True,将实例化一个ListSerializer类来序列化或者反序列化类。（这也是看源码是漏掉的地方，一直奇怪普通Serialiszer类怎么没看到对多对象序列化的特殊处理。查看BaseSerializer.__new__方法）或者class Meta:中定义了list_serializer_class指定的多对象序列化类。修改情况要用instance指明要修改的对象：5.终于弄懂了，partial用于部分更新，为啥子要伴随instance,因为要指明给save用，在save操作时给那个instance部分更新。逻辑这回走到下面源码中的get_initial()获取要进行更新instance的字段数据。]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架（二）]]></title>
    <url>%2Fposts%2Fb6a7d53b.html</url>
    <content type="text"><![CDATA[解析模块为什么要配置解析模块 1231）drf给我们提供了多种解析数据包方式的解析类 form-data/urlencoded/json2）我们可以通过配置来控制前台提交的哪些格式的数据后台在解析，哪些数据不解析3）全局配置就是针对每一个视图类，局部配置就是针对指定的视图来，让它们可以按照配置规则选择性解析数据 源码入口 1234567891011# APIView类的dispatch方法中request = self.initialize_request(request, *args, **kwargs) # 点进去#准备要解析的数据parser_context=self.get_parser_context(request) #不是重点# 解析模块，获取解析类parsers=self.get_parsers() # 点进去# 去类属性(局部配置) 或 配置文件(全局配置) 拿 parser_classesreturn [parser() for parser in self.parser_classes] 解析模块源码：rest_framework/parsers.py 自定义全局配置：项目settings.py文件 12345678REST_FRAMEWORK = &#123; # 全局解析类配置 &apos;DEFAULT_PARSER_CLASSES&apos;: [ &apos;rest_framework.parsers.JSONParser&apos;, # json数据包 &apos;rest_framework.parsers.FormParser&apos;, # urlencoding数据包 &apos;rest_framework.parsers.MultiPartParser&apos; # form-date数据包 ],&#125; 自定义局部配置：应用views.py的具体视图类（设置了局部就不用设置全局） 12345from rest_framework.parsers import JSONParserclass Book(APIView): # 局部解析类配置，只要json类型的数据包才能被解析 parser_classes = [JSONParser] pass 代码示例 在局部设置只能解析json格式数据，在postman其他格式传递的数据都不显示 url拼接的参数，通过request.query_params获取参数。数据包传参通过request.data获取 123456789101112131415from . import modelsfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.parsers import JSONParser #用作解析类class Book(APIView): # 局部解析类配置,post提交数据只能解析json格式数据 parser_classes = [JSONParser] #如果[]为空，那么就相当于没有设置解析类型 def post(self, request, *args, **kwargs): # url拼接参数：只有一种传参方式就是拼接参数 print(request.query_params) # 数据包参数：有三种传参方式，form-data、urlencoding、json print(request.data) return Response(&apos;post ok&apos;) 异常模块 (走到逻辑异常都能被控制)为什么要自定义异常模块 12341）所有经过drf的APIView视图类产生的异常，都可以提供异常处理方案2）drf默认提供了异常处理方案(rest_framework.views.exception_handler)，但是处理范围有限3）drf提供的处理方案两种，处理了返回异常现象，没处理返回None(后续就是服务器抛异常给前台)4）自定义异常的目的就是解决drf没有处理的异常，让前台得到合理的异常信息返回，后台记录异常具体信息 源码分析 123456789101112# 异常模块：APIView类的dispatch方法中response = self.handle_exception(exc) # 点进去#自定义异常就是提供异常处理函数exception_handler,处理的目的就是让response一定有值#自定义：自己写exception_handler函数，在自己的配置文件配置EXCEPTION_HANDLER指向自己的处理异常函数exception_handler = self.get_exception_handler() #点进去 #获取处理异常的方法，也可以自定义异常处理方法，在settings文件中配置#settings中获取异常处理的方式return self.settings.EXCEPTION_HANDLER#异常处理的结果 # 自定义异常就是提供exception_handler异常处理函数，处理的目的就是让response一定有值response = exception_handler(exc, context) #最后发现在views中的exception_handler就是处理异常的方法 如何使用：自定义exception_handler函数如何书写实现体 12345# 修改自己的配置文件setting.pyREST_FRAMEWORK = &#123; # 全局配置异常模块 &apos;EXCEPTION_HANDLER&apos;: &apos;api.exception.exception_handler&apos;, #设置自定义异常文件路径，在api应用下创建exception文件，exception_handler函数&#125; api应用下创建处理异常文件exception.py 123456789101112131415161718191）先将异常处理交给rest_framework.views的exception_handler去处理 （******）2）判断处理的结果(返回值)response，有值代表drf已经处理了，None代表drf处理不了的异常，需要自定义去处理 （******）# 自定义异常处理文件exception，重写exception_handler函数from rest_framework.views import exception_handler as drf_exception_handler #drf原生处理异常函数取别名 drf_exception_handlerfrom rest_framework.views import Responsefrom rest_framework import statusdef exception_handler(exc, context): #自定义处理异常函数 # drf的exception_handler做基础处理 response = drf_exception_handler(exc, context) # 为空，就是drf框架处理不了的异常 if response is None: #处理之后为空，再进行自定义的二次处理 # print(exc) #错误原因 还可以做更详细的原因，通过判断exc信息类型 # print(context) #错误信息 print(&apos;%s - %s - %s&apos; % (context[&apos;view&apos;], context[&apos;request&apos;].method, exc)) return Response(&#123; &apos;detail&apos;: &apos;服务器错误&apos; &#125;, status=status.HTTP_500_INTERNAL_SERVER_ERROR, exception=True) return response #处理之后有值，就直接返回结果 异常模块的大致流程：从dispatch中的handle_exception进入，get_exception_handler()获得处理异常方法exception_handler()，在这里也可以自定义异常方法。执行exception_handler()获取异常处理的结果。 响应模块响应类构造器：rest_framework.response.Response 123456789101112def __init__(self, data=None, status=None, template_name=None, headers=None, exception=False, content_type=None): &quot;&quot;&quot; :param data: 响应数据 :param status: http响应状态码 :param template_name: drf也可以渲染页面，渲染的页面模板地址（不用了解） :param headers: 响应头 :param exception: 是否异常了 :param content_type: 响应的数据格式（一般不用处理，响应头中带了，且默认是json） &quot;&quot;&quot; pass 使用：常规实例化相应对象 1234# status就是解释一堆 数字 网络状态码的模块from rest_framework import status就是解释一堆 数字 网络状态码的模块# 一般情况下只需要返回数据，status和headers都有默认值return Response(data=&#123;数据&#125;, status=status.HTTP_200_OK, headers=&#123;设置的响应头&#125;) 序列化组件（下面都是讲关于Serializer）知识点：Serializer(偏底层)、ModelSerializer(重点)、ListModelSerializer(辅助群改) 为什么使用序列化组件：因为视图中查询到的对象和queryset类型不能直接作为数据返回给前台，所以要使用序列化组件（\****）** 1.定义Serializer类 模型层：models.py 12345678910111213141516171819class User(models.Model): SEX_CHOICES = [ [0,&apos;男&apos;], [1,&apos;女&apos;], ] name = models.CharField(max_length=64) pwd = models.CharField(max_length=32) phone = models.CharField(max_length=11,null=True,default=None) sex = models.IntegerField(choices=SEX_CHOICES,default=0) icon = models.ImageField(upload_to=&apos;icon&apos;,default=&apos;icon/default.jpg&apos;) class Meta: db_table=&apos;old_boy_user&apos; verbose_name=&apos;用户&apos; verbose_name_plural=verbose_name def __str__(self): return &apos;%s&apos; %self.name 自定义序列化类（自定义serializer类）： 1234567from rest_framework import serializersclass User(serializers.Serializer): id = serializers.IntergetField() #序列化括号里面不用加条件 name = serializer.CharField() . . . 配置层：settings.py 12345# 注册rest_frameworkINSTALLED_APPS = [ # ... &apos;rest_framework&apos;,] 2.分析源码创建Serializer对象中参数** 源码分析 BaseSerializer 1def __init__(self, instance=None, data=empty, **kwargs): 定义好Serialzier类后，就可以创建Serializer对象了。 Serializer的构造方法为： 1Serializer(instance=None,data=empty,**kwargs) 说明： 1.用于序列化时，将模型类对象传入instance参数 2.用于反序列化时，将要被反序列化的数据传入data参数 3.除了instance和data参数外，在构造Serializer对象时，还可以通过context参数额外添加数据 通过context参数附加的数据，可以通过Serializer对象的context属性获取 1serializer = AccountSerializer(account,context=&#123;&apos;request&apos;:request&#125;) 总结注意：**12345671.使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以2.序列化器无法直接接收数据，需要我们在视图中创建序列化器对象时把使用的数据传递过来。（data,instance传参）序列化是：数据对象从数据库中查出，通过instance传入序列化器中，必须通过data属性才能将序列化后的数据传给前端，不能直接传序列化对象反序列化是：数据是通过request.data从前端获取到数据，通过data传入序列化器中进行校验，保存到数据库中3.序列化器的字段声明类似于我们前面使用过的表单系统4.开发restful api时，序列化器会帮我们把模型数据转换成字典。5.drf提供的视图会帮我们把字典转换成json，或者把客户端发过来的数据转换成字典 3.序列化器的使用 序列化器的使用分两个阶段： 1.在客户端请求时：使用序列化器可以完成对数据的反序列化（就是前段往后端传递数据，反序列化之后保存数据） 2.在服务器响应时，使用序列化器可以完成对数据的序列化（服务器取出数据，序列化之后往前段发送展示） 序列化使用流程： 基本使用： 1.先查询出一个用户对象 12from models import useruser = User.object.get(id=2) 2.构造序列化器对象 12from user.serializers import UserSerializeruser_obj = Userserializer(user) #放入查询出的user对象 3.获取序列化对象 通过data属性可以获取序列化后的数据 12上面查出来的user_ser是一个serializer对象，需要取出具体的数据传给前端，所有要用到 user_ser.data取出具体数据user_ser = Userserializer(user).data 4.如果要被序列化的数据是包含多条数据的（也可以说被[ ]嵌套的，queryset类型数据，不管是多条还是单条）,需要添加many=True参数 12user = models.User.objects.all()user_ser = Userserialzier(user,many=True) 5.自定义序列化属性(重点\****) 下面有代码示例具体操作** 1serializers.SerializerMethodField() 反序列化使用流程： 数据验证： 1.使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。 2.在获取反序列化的数据前，必须调用is_valid()方法进行验证，验证成功返回True，否则返回False。 3.验证失败，可以通过序列化对象的errors属性获取错误信息，返回字典，包含了字段和字段的错误。 4.验证通过，可以通过序列化器对象的validated_data属性获取数据 保存数据： 序列化类中必须重写create方法用于新增，重写update方法是修改 视图中使用create()和save()方法 1从源码可知save()方法内部调用的是序列化类中的create方法，所以新增必须要在序列化类中重写create方法 4.代码示例序列化和反序列化在Serialzier组件中使用 序列化使用（展示给前台的数据） 序列化层：api/serializers.py (api应用下创建serializers.py文件) 121）设置需要返回给前台数据样式 那些model类有对应的字段，不需要返回的就不用设置了2）设置方法字段，字段名可以随意，字段值由 get_字段名 提供，来完成一些需要处理在返回的数据,类似于forms组件 1234567891011121314151617181920212223242526from rest_framework import serializers, exceptionsfrom django.conf import settingsfrom . import modelsclass UserSerializer(serializers.Serializer): #创建一个序列化类 name = serializers.CharField() phone = serializers.CharField() # 序列化提供给前台的字段个数由后台决定，可以少提供，但是提供的数据库对应的字段，名字一定要与数据库字段相同 # sex = serializers.IntegerField() # icon = serializers.ImageField() # 自定义序列化属性 # 属性名随意，值由固定的命名规范方法提供: # get_属性名(self, 参与序列化的model对象) # 返回值就是自定义序列化属性的值 gender = serializers.SerializerMethodField() def get_gender(self, obj): # choice类型的解释型值 get_字段_display() 来访问 return obj.get_sex_display() #自定义序列化属性icon icon = serializers.SerializerMethodField() def get_icon(self, obj): # settings.MEDIA_URL: 自己配置的 /media/，给后面高级序列化与视图类准备的 # obj.icon不能直接作为数据返回，因为内容虽然是字符串，但是类型是ImageFieldFile类型 return &apos;%s%s%s&apos; % (r&apos;http://127.0.0.1:8000&apos;, settings.MEDIA_URL, str(obj.icon)) 视图层 12345678910111213视图层书写的三个步骤1）从数据库中将要序列化给前台的model对象，或是多个model对象查询出来 user_obj = models.User.objects.get(pk=pk) 或者 user_obj_list = models.User.objects.all()2）将对象交给序列化处理，产生序列化对象，如果序列化的数据是由[]嵌套，一定要设置many=True user_ser = serializers.UserSerializer(user_obj) 或者 user_ser = serializers.UserSerializer(user_obj_list, many=True)3）序列化 对象.data 就是可以返回给前台的序列化数据 return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: 0, &apos;results&apos;: user_ser.data &#125;) 1234567891011121314151617181920212223242526272829class User(APIView): def get(self, request, *args, **kwargs): pk = kwargs.get(&apos;pk&apos;) if pk: #单查 try: # 用户对象不能直接作为数据返回给前台 user_obj = models.User.objects.get(pk=pk) # 序列化一下用户对象 user_ser = serializers.UserSerializer(user_obj) return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: 0, &apos;results&apos;: user_ser.data #如果你在序列化的时候没有.data,那么在传给前端的时候必须要.data &#125;) except: return Response(&#123; &apos;status&apos;: 2, &apos;msg&apos;: &apos;用户不存在&apos;, &#125;) else: #群查 # 用户对象列表(queryset)不能直接作为数据返回给前台 user_obj_list = models.User.objects.all() # 序列化一下用户对象 user_ser_data = serializers.UserSerializer(user_obj_list, many=True).data return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: 0, &apos;results&apos;: user_ser_data &#125;) 反序列化使用 （把数据存入数据库） 反序列层：api/serializers.py 12341）设置必填与选填序列化字段，设置校验规则2）为需要额外校验的字段提供局部钩子函数，如果该字段不入库，且不参与全局钩子校验，可以将值取出校验 pop3）为有联合关系的字段们提供全局钩子函数，如果某些字段不入库，可以将值取出校验4）必须重写create方法，完成校验通过的数据入库工作，得到新增的对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class UserDeserializer(serializers.Serializer): # 1) 哪些字段必须反序列化 # 2) 字段都有哪些安全校验 # 3) 哪些字段需要额外提供校验 钩子函数 # 4) 哪些字段间存在联合校验 # 注：反序列化字段都是用来入库的，不会出现自定义方法属性，会出现可以设置校验规则的自定义属性,不入数据库的 name = serializers.CharField( max_length=64, min_length=3, error_messages=&#123; &apos;max_length&apos;: &apos;太长&apos;, &apos;min_length&apos;: &apos;太短&apos; &#125; ) pwd = serializers.CharField() phone = serializers.CharField(required=False) sex = serializers.IntegerField(required=False) # 自定义有校验规则的反序列化字段,例如确认密码字段re_pwd re_pwd = serializers.CharField(required=True) # 小结： # name，pwd，re_pwd为必填字段 # phone，sex为选填字段 # 五个字段都必须提供完成的校验规则 # 局部钩子：validate_要校验的字段名(self, 当前要校验字段的值) # 校验规则：校验通过返回原值，校验失败，抛出异常 def validate_name(self, value): if &apos;g&apos; in value.lower(): # 名字中不能出现g raise exceptions.ValidationError(&apos;名字非法，是个鸡贼！&apos;) return value # 全局钩子：validate(self, 通过系统与局部钩子校验之后的所有数据) # 校验规则：校验通过返回原值，校验失败，抛出异常 def validate(self, attrs): #attrs是字典格式 pwd = attrs.get(&apos;pwd&apos;) re_pwd = attrs.pop(&apos;re_pwd&apos;) #因为re_pwd不需要入数据库，所以在全局钩子校验中删除掉这个字段 if pwd != re_pwd: raise exceptions.ValidationError(&#123;&apos;pwd&amp;re_pwd&apos;: &apos;两次密码不一致&apos;&#125;) return attrs # 要完成新增，必须自己重写 create 方法，validated_data是校验的数据 def create(self, validated_data): # 尽量在所有校验规则完毕之后，数据可以直接入库 return models.User.objects.create(**validated_data) 视图层:views.py 1234反序列化视图层三步：1）book_ser = serializers.UserDeserializer(data=request_data) # 反序列化数据必须赋值data,结果就是得到一个serializer对象2）book_ser.is_valid() # 把数据放到自定义serializer中校验，数据校验成功返回True,失败返回False3）不通过返回 book_ser.errors 给前台，通过 book_ser.save() 得到新增的对象，再正常返回 1234567891011121314151617181920212223242526272829class User(APIView): # 只考虑单增 def post(self, request, *args, **kwargs): # 请求数据 request_data = request.data # 数据是否合法（增加对象需要一个字典数据） if not isinstance(request_data, dict) or request_data == &#123;&#125;: return Response(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;数据有误&apos;, &#125;) # 数据类型合法，但数据内容不一定合法，需要校验数据，校验(参与反序列化)的数据需要赋值给data book_ser = serializers.UserDeserializer(data=request_data) # 序列化对象调用is_valid()完成校验，校验失败的失败信息都会被存储在 序列化对象.errors if book_ser.is_valid(): # 校验通过，完成新增 book_obj = book_ser.save() return Response(&#123; &apos;status&apos;: 0, &apos;msg&apos;: &apos;ok&apos;, &apos;results&apos;: serializers.UserSerializer(book_obj).data &#125;) else: # 校验失败 return Response(&#123; &apos;status&apos;: 1, &apos;msg&apos;: book_ser.errors, &#125;)]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DRF框架（一）]]></title>
    <url>%2Fposts%2Ff97f4f6b.html</url>
    <content type="text"><![CDATA[搬运自:https://www.cnblogs.com/wangcuican/p/11748025.html 做备份 DRF框架全称：django-rest framework 知识点 123456接口：什么是接口、restful接口规范CBV生命周期源码 - 基于restful规范下的CBV接口请求组件、解析组件、响应组件序列化组件(灵魂)三大认证(重中之重)：认证、权限(权限六表)、频率其他组件：过滤、筛选、排序、分页、路由 接口123456接口：联系两个物质的媒介，完成信息交互web程序中：联系前台页面与后台数据库的媒介web接口组成： url：长得像返回数据的url链接 请求参数：前台按照指定的key提供数据给后台 响应数据：后台与数据库交互后将数据反馈给前台 restful接口规范12345接口规范：就是为了采用不同的后台语言，也能使用同样的接口获取到同样的数据如何写接口：接口规范是 规范化书写接口的，写接口要写 url、响应数据 注：如果将请求参数也纳入考量范围，那就是在写 接口文档 两大部分： url 12345678910111213141516171819201) 用api关键字标识接口url api.baidu.com | www.baidu.com/api 2) 接口数据安全性决定优先选择https协议3) 如果一个接口有多版本存在，需要在url中标识体现 api.baidu.com/v1/... | api.baidu.com/v2/... 4) 接口操作的数据源称之为 资源，在url中一般采用资源复数形式，一个接口可以概括对该资源的多种操作方式 api.baidu.com/books | api.baidu.com/books/(pk) 5) 请求方式有多种，用一个url处理如何保证不混乱 - 通过请求方式标识操作资源的方式 /books get 获取所有/获取一个 /books post 增加一个(多个) /books/(pk) delete 删除一个 params传参 /books/(pk) put 整体更新一个 /books/(pk) patch 局部更新一个6) 资源往往涉及数据的各种操作方式 - 筛选、排序、限制 api.baidu.com/books/?search=西&amp;ordering=-price&amp;limit=3 响应数据 就是下面的JsonResponse，返回给前端的数据 1234567891011121) http请求的响应会有响应状态码，接口用来返回操作的资源数据，可以拥有 操作数据结果的 状态码 status 0(操作资源成功) 1(操作资源失败) 2(操作资源成功，但没匹配结果) 注：资源状态码不像http状态码，一般都是后台与前台或是客户约定的 2) 资源的状态码文字提示 status ok &apos;账号有误&apos; &apos;密码有误&apos; &apos;用户锁定&apos; 3) 资源本身 results 注：删除资源成功不做任何数据返回(返回空字符串) 4) 不能直接放回的资源(子资源、图片、视频等资源)，返回该资源的url链接 基于restful规范的原生Django接口用规范的方法写django查询和增加范例 主路由 urls.py 1234567from django.conf.urls import url,includefrom django.contrib import adminurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^app01/&apos;, include(&apos;app01.urls&apos;)),] 应用app01下的urls.py 1234567from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r&apos;^books/$&apos;, views.Book.as_view()), url(r&apos;^books/(?P&lt;pk&gt;.*)/$&apos;, views.Book.as_view()),] 模型层 models.py 创建数据 12345678910111213from django.db import modelsclass Book(models.Model): title = models.CharField(max_length=64) price = models.DecimalField(max_digits=5,decimal_places=2) #生成五位数，小数两位 class Meta: db_table = &apos;old_boy_book&apos; #设置数据库名 verbose_name = &apos;书籍&apos; #设置中文名 verbose_name_plural = verbose_name #需要设置这个不然verbose_name会变成书籍s def __str__(self): return &apos;《%s》&apos; %self.title 后台层admin.py 创建登录admin页面 12345from django.contrib import adminfrom . import modelsadmin.site.register(models.Book) 创建超级用户 1&gt;: createsuperuser 数据库迁移 12&gt;: python manage.py makemigrations&gt;: python manage.py migrrate 视图层：views.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from django.http import JsonResponsefrom django.views import Viewfrom . import modelsclass Book(View): #查询 def get(self,request,*args,**kwargs): # print(args) #无名参数是元组 print(kwargs) #有名分组是字典 pk = kwargs.get(&apos;pk&apos;) if not pk: #群查 #操作数据库查询 book_obj_list = models.Book.objects.all() # print(book_obj_list) #序列化数据(把每条数据放在一个字典中，把所有字典数据放在一个list中,数据更好看) book_list = [] for obj in book_obj_list: dic = &#123;&#125; dic[&apos;title&apos;] = obj.title dic[&apos;price&apos;] = obj.price book_list.append(dic) #响应数据（后台返回给前台的数据） return JsonResponse(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:book_list &#125;,json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) #取消中文转义 else: #单查 book_dic = models.Book.objects.filter(pk=pk).filter().values(&apos;title&apos;,&apos;price&apos;).first() #如果不写first()，还是queryset对象 &lt;QuerySet [&#123;&apos;title&apos;: &apos;气球&apos;, &apos;price&apos;: Decimal(&apos;555.00&apos;)&#125;]&gt; # print(book_dic) # &#123;&apos;title&apos;: &apos;气球&apos;, &apos;price&apos;: Decimal(&apos;555.00&apos;)&#125; if book_dic: return JsonResponse(&#123; &apos;status&apos;: 0, &apos;msg&apos;: &apos;ok&apos;, &apos;results&apos;: book_dic &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) # 取消中文转义 #没有查询到数据 return JsonResponse(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;没有查询到结果&apos;, &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) # 取消中文转义 #增加 def post(self,request,*args,**kwargs): # print(request.POST.dict()) #&#123;&apos;title&apos;: &apos;西游记&apos;, &apos;price&apos;: &apos;4.55&apos;&#125; try: book_obj = models.Book.objects.create(**request.POST.dict()) #create增加数据 if book_obj: return JsonResponse(&#123; &apos;status&apos;:0, &apos;msg&apos;:&apos;ok&apos;, &apos;results&apos;:&#123;&apos;title&apos;:book_obj.title,&apos;price&apos;:book_obj.price&#125; &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) except: return JsonResponse(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;参数错误&apos;, &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) return JsonResponse(&#123; &apos;status&apos;: 1, &apos;msg&apos;: &apos;增加错误&apos;, &#125;, json_dumps_params=&#123;&apos;ensure_ascii&apos;: False&#125;) Postman接口工具 12345671.官网下载安装2.get请求，携带参数采用Params，传值3.post等请求，在Body里面加数据，提交数据包可以采用三种方式：form-date、urlencoding、json，原生的django对urlencoding方式数据兼容最好所有请求都可以携带请求头 原生Django CBV请求生命周期源码分析： 1https://www.cnblogs.com/wangcuican/p/11991750.html DRF框架安装 1&gt;: pip install djangorestframework drf框架规矩的封装风格 views.py 1234567891011121314from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.request import Requestfrom rest_framework.serializers import Serializerfrom rest_framework.settings import APISettingsfrom rest_framework.filters import SearchFilter #过滤from rest_framework.pagination import PageNumberPagination #分页from rest_framework.authentication import TokenAuthentication #认证from rest_framework.permissions import IsAuthenticated #权限（是否登录）from rest_framework.throttling import SimpleRateThrottle #频率class Test(APIView): def get(self, request, *args, **kwargs): return Response(&apos;drf get ok&apos;) drf请求生命周期流程（重点\****）** 1234567891) 根据应用中urls.py,走as_view方法，但是视图类没有该方法，所以请求走的是APIView的as_view方法2) 在APIView的as_view调用父类(django原生View)的as_view，同时还禁用了 csrf 认证3) 在父类（django原生View）的as_view中dispatch方法请求走的又是APIView的dispatch #因为APIView也可以走dispatch,视图类是先继承APIView,APIView中没有再去原生View中4) 完成任务方法交给视图类的请求函数处理，得到请求的响应结果，返回给前台所以以后直接就从APIView的dispatch入口看源码 请求模块：request对象源码入口 1APIView类的dispatch方法中：request = self.initialize_request(request, *args, **kwargs) 源码分析 1234567891011121314151617# 二次封装request (请求模块)request = self.initialize_request(request, *args, **kwargs) #点进去#点击查看Request源码return Request( request, ...)# 在rest_framework.request.Request实例化方法中self._request = request #将原生request作为drf request的_request属性# 在rest_framework.request.Request的__getattr__方法中try: return getattr(self._request, attr) # 访问属性完全兼容原生requestexcept AttributeError: return self.__getattribute__(attr) Request源码地址在:rest_framework/requests.py 重点总结 123451) drf 对原生request做了二次封装，设置request._request等于原生request2) 原生request对象的属性和方法都可以被drf的request对象直接访问(兼容)3) drf请求的所有url拼接参数均被解析到query_params中，所有数据包数据都被解析到data中 (******)get请求：url中拼接的参数通过request.query_params获取post请求：所有请求方式所携带的数据包都是通过request.data获取 请求模块最终的结论就是**：获取数据有两种方式 query_params和data（通过parser解析数据传到data）** 使用drf写的get/post请求 123456789101112131415161718class Test(APIView): def get(self, request, *args, **kwargs): # url拼接的参数 print(request._request.GET) # 二次封装方式 print(request.GET) # 兼容 print(request.query_params) # 拓展 return Response(&apos;drf get ok&apos;) def post(self, request, *args, **kwargs): # 所有请求方式携带的数据包 print(request._request.POST) # 二次封装方式 print(request.POST) # 兼容 print(request.data) # 拓展，兼容性最强，三种传参方式都可以：form-data,urlencoding,json print(request.query_params) return Response(&apos;drf post ok&apos;) 渲染模块：浏览器和Postman请求结果渲染数据的方式不一样 源码入口 1APIView类的dispatch方法中：self.response = self.finalize_response(request, response, *args, **kwargs) 源码分析 1234567891011121314# 最后解析reponse对象数据self.response = self.finalize_response(request, response, *args, **kwargs) #点进去# 拿到运行的解析类的对象们neg = self.perform_content_negotiation(request, force=True) #点进去# 获得解析类对象renderers = self.get_renderers() #点进去# 从视图类中得到renderer_classes请求类，如何实例化一个个对象形参解析类对象列表return [renderer() for renderer in self.renderer_classes] #配置文件重点：从self.renderer_classes获取renderer_classes，然后从api_settings中获取渲染模块的配置 1.自己视图类的类属性(局部配置) =&gt; 2.APIView类的类属性设置 =&gt; 3.自己配置文件的DEFAULT_RENDERER_CLASSES(全局配置) =&gt; 4.drf配置文件的DEFAULT_RENDERER_CLASSES 渲染模块源码地址：rest_framework/renderers.py 自定义全局配置：所有视图类统一处理，在项目的settings.py中（\****）** 1234567REST_FRAMEWORK = &#123; # drf提供的渲染类 &apos;DEFAULT_RENDERER_CLASSES&apos;: [ &apos;rest_framework.renderers.JSONRenderer&apos;, #只显示出json数据 &apos;rest_framework.renderers.BrowsableAPIRenderer&apos;, #渲染出页面，注意是BrowsableAPIRenderer ],&#125; 自定义局部配置：某一个或一些实体类单独处理，在views.py视图类中提供对应的类属性（\****）** 1234567891011# 在setting.py中配置REST_FRAMEWORK，完成的是全局配置，所有接口统一处理# 如果只有部分接口特殊化，可以完成 - 局部配置from rest_framework.renderers import JSONRendererclass Test2(APIView): # 局部配置 renderer_classes = [JSONRenderer] def get(self, request, *args, **kwargs): return Response(&apos;drf get ok 2&apos;) def post(self, request, *args, **kwargs): return Response(&apos;drf post ok 2&apos;)]]></content>
      <categories>
        <category>DRF框架</category>
      </categories>
      <tags>
        <tag>DRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019总结]]></title>
    <url>%2Fposts%2Fac33bbfd.html</url>
    <content type="text"><![CDATA[2019总结：1.买一套200w的房子（已完成)2.买一辆特斯拉（已完成）3.存款200w（已完成）4.有一次说走就走的旅行（已完成）5.改掉吹牛逼的习惯（未完成）]]></content>
  </entry>
  <entry>
    <title><![CDATA[圣诞节]]></title>
    <url>%2Fposts%2Fa810acad.html</url>
    <content type="text"><![CDATA[圣诞节快乐啊！ 圣诞节下雨了！睡个好觉~ 晚安ps：偃师]]></content>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取电子书]]></title>
    <url>%2Fposts%2Fd182bfab.html</url>
    <content type="text"><![CDATA[这几天刚学习了爬虫，准备自己操作一下爬个小说网站使用的requesets获取数据 然后使用xpath解析数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#! /usr/bin/env python# -*- coding:utf-8 -*-import requestsfrom lxml import etreeimport timeclass NovelSpider(object): def __init__(self): self.base_url = &apos;http://www.xbiquge.la&#123;&#125;&apos; self.headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&apos;, &apos;Cookie&apos;: &apos;_abcde_qweasd=0; _abcde_qweasd=0; username=ixieyu&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;&#125; self.data_list = [] # 1.发送请求 def get_response(self,url): response = requests.get(url,headers=self.headers) data = response.content return data # 2.解析数据 获取到文章标题 链接 def parse_list_data(self,data): html = etree.HTML(data) title_list = html.xpath(&quot;//div[@id=&apos;list&apos;]//a/text()&quot;) content_url = html.xpath(&quot;//div[@id=&apos;list&apos;]//a/@href&quot;) for index,title in enumerate(title_list): temp_dict = &#123;&#125; temp_dict[&apos;title&apos;] = title temp_dict[&apos;content_url&apos;] = &apos;http://www.xbiquge.la&apos; + content_url[index] self.data_list.append(temp_dict) # 解析文章页 获取小说标题 内容 def parse_content_data(self,data): html = etree.HTML(data) title_list = html.xpath(&quot;//div[@class=&apos;bookname&apos;]/h1/text()&quot;) content = html.xpath(&quot;//div[@id=&apos;content&apos;]/text()&quot;) self.save_data(title_list[0]) self.save_data(&apos;\n&apos;) for con in content: data = str(con).replace(&apos; &apos;,&apos;&apos;) data1 = data.replace(&apos;;&apos;,&apos;&apos;) self.save_data(data1) # self.save_data(&apos;\n&apos;) # 3.保存数据 def save_data(self,data): with open(&apos;qingyunian.txt&apos;,&apos;a+&apos; ,encoding=&apos;utf-8&apos;)as f: f.write(data) # 4.运行 def start(self): url = self.base_url.format(&apos;/1/1690&apos;) data = self.get_response(url) self.parse_list_data(data) # 遍历data_list 获取文章url for data in self.data_list: content_url = data[&apos;content_url&apos;] print(&apos;正在爬取&apos;+content_url) content_data = self.get_response(content_url) self.parse_content_data(content_data) time.sleep(1) print(&apos;下载完成！&apos;)NovelSpider().start()]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习]]></title>
    <url>%2Fposts%2F28f95297.html</url>
    <content type="text"><![CDATA[十一月四号从哈尔滨西到北京。 周天 一路上幻想办公室生活的趣味，到了地方发现就是一居室的工作室，和我想得出入很大，当天和公司几个人吃了晚饭，水煮鱼。不是中规中矩的写字楼格子间，而是随意的工作、从招标到实施都是几个人完成。 周一 跟雷哥跑业务去招标，发现投标的公司是长安通信，心里好酸啊。早上去的早，公司招标要下午两点开始，没地方去，就在周围公园干坐着三个小时，中午在便利店吃的微波炉加热的便当。当晚上就坐着火车去往了洛阳。 周二 早上到了洛阳，经过了一个小时的公交到达最终的目的地偃师，是一个县级市，我看着也就和龙江差不多，住在酒店，休息了一会就去附近看看房子。下午去办公室报到，就是简单的聊一聊，聊过之后就回酒店苟着了。 周三 上午没事，下午找中介看房子，看了一个两居室的，很破是老房子，好在有家具东西齐全。晚上得到消息周四回郑州。 周四 十点多坐客车去郑州，公司在郑州大学租的公寓，一室一厅很挤，我和雷哥住房间，老陈住客厅。 周五 和老陈去机房看看，帮忙干零活，下午呆了一会，然后晚上十二点机房停运，全忙两个小时。 周六 雷哥说不用我去了，一是 回郑州这边就是帮忙，不用去这么多人，二是 我工作的方向是软件方向和硬件没太多关系。我觉得是 去也帮不了太多忙，浪费时间。上午去小米之家换了电池，溜达了一大圈。晚上去附近走了走，想着去郑州大学里面走一走，绕了好大一圈走到正门口发现要刷卡能进，随即我就骑着小蓝车往回走了！！！！ 周天 上午不想动在宿舍苟着，下午看了电影，晚上出去骑车到广场，比我想象中的要小好多，就和台州商业街那的广场差不多，失望的回来。寻思着晚上弄弄爬虫爬学校的教务处，学校网站还登录不上去了，在之后谢博客写到现在22：58。睡了~晚安]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2F21a87fc2.html</url>
    <content type="text"><![CDATA[记录一下好久都没有的1w步。随着上学期加入实验室，之后大多的时间就是坐在椅子上，每天的活动量大概就是走到食堂的距离吧，每天的运动步数都不超过5k。下午的时候和同学去体育馆打羽毛球，回来之后小臂、大腿酸痛，乳酸堆积。运动之后的舒爽消除了我肩颈酸痛。看来以后还是要劳逸结合。顺便附带手环照。(请忽略我的手腕…)安啦~]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis数据库-操作]]></title>
    <url>%2Fposts%2F8ce91e30.html</url>
    <content type="text"><![CDATA[了解Redis存储数据结构。 数据结构 Redis是key-value的数据结构，每条数据都是一个键值对 键的类型是字符串 注意：键不能重复 值得类型有: 字符串string 哈希hash 列表list 结合set 有序集合zset 数据操作行为 保存 修改 获取 删除 string类型 字符串类型是Redis中最为基础得数据存储类型，它在Redis中是二进制安全得，这便意味着该类型可以接收任何格式得数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型得value最多可以容纳的数据长度是512M。 保存如果设置的键不存在的则为添加，如果设置的键已经存在则修改 设置键值 set key value 设置键为name值为redis set name redis 设置键值及过期时间，以秒为单位 setex key seconds value 设置多个键值 mset key1 value1 key2 value2 … 追加值 append key value 获取 获取:根据键获取值，如果不存在此键则返回nil get key 根据多个键获取多个值 mget key1 key2 删除参看键命令 键命令 查找键,参数支持正则表达式 keys pattern 查看所有键 keys * 查看名称中包含a的键 keys ‘a*’ 判断键是否存在，如果存在返回1，不存在返回 exists key1 查看键对应的value的类型 type key 删除键及对应的值 del key1 key2 … 设置过期时间，以秒为单位 如果没有指定过期时间则⼀直存在，直到使⽤DEL移除 expire key seconds 查看有效时间，以秒为单位 ttl key hash用于存储对象，对象的结构为属性、值值得类型为string 增加、修改 设置单个属性 hset key field value 设置多个属性 hmset key field1 value1 field2 value2 … 获取 获取指定键所有的属性 hkeys key 获取一个属性的值 hget key field 获取多个属性的值 hmget key field1 field2 … 获取所有属性的值 hvals key 删除删除整个hash键及值，使⽤del命令删除属性，属性对应的值会被⼀起删除 hdel key field1 field2 … list列表的元素类型为string按照插入顺序排序 增加 在左侧插⼊数据 lpush key value1 value2 … 在右侧插⼊数据 rpush key value1 value2 … 在指定元素的前或后插⼊新元素 linsert key before或after 现有元素 新元素 获取 返回列表⾥指定范围内的元素 start、stop为元素的下标索引 索引从左侧开始，第⼀个元素为0 索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素 lrange key start stop 设置指定索引位置得元素值 索引从左侧开始，第⼀个元素为0 索引可以是负数，表示尾部开始计数，如-1表示最后⼀个元素 lset key index value 删除 删除指定元素 将列表中前count次出现的值为value的元素移除 count &gt; 0: 从头往尾移除 count &lt; 0: 从尾往头移除 count = 0: 移除所有 lrem key count value set无序集合元素为string元素具有唯一性，不重复说明:对于集合没有修改操作 增加 添加元素 sadd key member1 member2 … 获取 返回所有的元素 smembers key 删除 删除指定元素 srem key value zset类型sorted set，有序集合元素为string类型元素具有唯⼀性，不重复每个元素都会关联一个double类型的score，表示权重，通过权重将元素从⼩到⼤排序说明：没有修改操作 增加 添加 zadd key score1 member1 score2 member2 … 获取 返回指定范围内的元素 start、stop为元素的下标索引 索引从左侧开始，第一个元素为0 索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素 zrange key start stop 返回score值在min和max之间的成员 zrangebyscore key min max 返回成员member的score值 zscore key member 删除 删除指定元素 zrem key member1 member2 … 删除权重在指定范围的元素 zremrangebyscore key min max]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据库]]></title>
    <url>%2Fposts%2Feb52a7b2.html</url>
    <content type="text"><![CDATA[Redis是一个高性能的key-value数据库。 NoSQL数据库:新一类出现的数据库(not only sql),它的特点： 不支持SQL语法 存储结构跟传统关系型数据库中的那种关系表完全不同，nosql中存储的数据都是Kv形式 NoSQL的世界中没有一种通用的语言，每种nosql数据库都有自己的api和语法，以及擅长的业务场景 NoSQL中的产品种类先当多 Mogodb Redis Hbase hadoop Cassandra hadoopRedis简介 Redis是一个开源的使用ANSI C语言编写支持网路，可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API。Redis特性 Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。Redis优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。Reids应用场景 用来做缓存(ehcache/memcached)——redis的所有数据是放在内存中的（内存数据库） 可以在某些特定应用场景下替代传统数据库——比如社交类的应用 在一些大型系统中，巧妙地实现一些特定的功能：session共享、购物车 只要你有丰富的想象力，redis可以用在可以给你无限的惊喜……. Reids官方网站 Reids中文官网]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的坑]]></title>
    <url>%2Fposts%2F1fd52e7b.html</url>
    <content type="text"><![CDATA[Python中的坑早踩早避免。找了很多最后还是github上比较全面详细链接:What the f*ck Python! 复制、浅拷贝、深拷贝 复制：直接赋值,传递对象的引用而已,原始对象改变，被赋值的对象也会做相同的改变 浅拷贝（切片操作、工厂函数、copy函数）：没有拷贝子对象，所以原始数据改变，子对象会改变 深拷贝：包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变 如果在循环引用中的对象定义了 del ,那么python gc不能进行回收，因此，存在内存泄漏的风险 or运算符 1if a == 3 or b == 3 or c == 3: 运行 1if a or b or c == 3: # Wrong 这是由于or的优先级低于==，所以表达式将被评估为if (a) or (b) or (c == 3):。可以使用 1234if a == 3 or b == 3 or c == 3: # Right Way if any([a == 3, b == 3, c == 3]): # Right if any(x == 3 for x in (a, b, c)): # Right if 3 in (a, b, c): # Right 列表的+和+=, append和extend 1234567891011121314151617181920212223242526In [17]: print('ID:', id(a_list))('ID:', 4481323592) In [18]: a_list += [1] In [19]: print('ID (+=):', id(a_list))('ID (+=):', 4481323592) # 使用+= 还是在原来的列表上操作 In [20]: a_list = a_list + [2] In [21]: print('ID (list = list + ...):', id(a_list))('ID (list = list + ...):', 4481293056) # 简单的+其实已经改变了原有列表In [28]: a_list = [] In [29]: id(a_list)Out[29]: 4481326976 In [30]: a_list.append(1) In [31]: id(a_list)Out[31]: 4481326976 # append 是在原有列表添加 In [32]: a_list.extend([2]) In [33]: id(a_list)Out[33]: 4481326976 # extend 也是在原有列表上添加]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flag]]></title>
    <url>%2Fposts%2F71c644a4.html</url>
    <content type="text"><![CDATA[这是一篇加密文章，内容是个人情感宣泄。如果你确实想看，请点击右下角蓝色小图标与我联系。 Incorrect Password! No content to display! U2FsdGVkX18+UmMzMBBqaZbIBwlvjNeDsBgP0UYFW+zL+4FvjG4qZJXApy7W4acPivAMB70OdThZGnk+GQ5qJiISc1cETaTEAdHoH9PM+hu3WmyU0S/ktcGmigPiKCmlqSUD+5fzZL78qKs+WPHeRIYDJoTWQju1Ycqgryqz7EFuPipoKDEHyy6DmNGaE2qXDIQDGv4VPJgvKiBIX4+tyhcGTOFv18akWNUCTL/18aRXxquKxLJsRlBY5YGw6jnIpC6MrQsr9TqMcb+wRvqov1xF0S8eHNXTPvgJDZJGbFuxdOFCwxSwXPta1UlkTYP2O1Lzrc7XoCoXUWQ9TKqqaOr5gbgnDsYjsOvqK0LZOcAPiyBp3I+CTzDkEfY4OT0w1oPBtI2zra0u5gvrD33Mjm0vU/2+6V5Hmvea307lvNnU8rOaTXLAunVoqk9ZClbPTrpT5YXDM4pOrd2sUl11nV281FL0W65343owzSn77RS3/Da4pgGu7ZgCB6wxdEgUWHeX4Zyptz4Ej3vmiBeXKcu4l5Ys3I38ytQZjnctG6PjZRAu0GA5594BS/DtjutxFCCG885Y19/FqRYLRlbTvyLAR/wEEDJTRFqsyDq82r0Ex4ZYQsIZZnk9lXXm/KLFkUGCGj/zi6pI/bD7Q17CC7fGXcNSxuCQ6YI8CPpRNOrDmiIR9xbap9TYZwLPFEu4rpJ8uoGHdo9ouwUCVju8ZM/uL5uCTZDLLiMO5baXcVnhdIBq5GvggtrMR5w7SgnNe8BOZVkTLom0J+rjCcP+0W+OH4PKvp1vqhk7CfH7/rl716J2STjBwfkV6a4TvUNtRdXJg6vdISZ5i4Uskk62EwlvWu/XLIMZ+57oXiNaY74YjbCnX8x3p9/Dwg16OJ4/dbIwkvzyhwyOeoVzTJ4/sNa3+mMVD5RV832Dvne7K4mblCH5bpsBjlNjJ441nRgbyOqT7jFtvGYSurIHxwutKxfsXOzsq6IeuFiYX6ykhOQ=]]></content>
      <tags>
        <tag>Flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰Git教程笔记]]></title>
    <url>%2Fposts%2F31ed5d2a.html</url>
    <content type="text"><![CDATA[Git–每一个程序员都必不可少的技能。Git是目前世界上最先进的分布式版本控制系统（没有之一）。 版本控制系统的作用 记录改动 协作编辑 Git的诞生Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们。但是！！！Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！在2008年，GitHub网站上线。 Git命令 新建代码库 12git init 在当前目录新建一个Git代码库 git init [program-name] 新建一个目录，将其初始化为Git代码库 配置 git config （–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 如果不加，那只针对当前的仓库起作用。） 1234567git config --list 显示当前的Git配置 git config --global user.name [username] git config --global user.email [email]git config --global color.ui true 配置Git显示颜色 增加/删除文件 12345678910111213141516git add [filename] 添加指定文件到暂存区(表示添加新文件和编辑过的文件不包括删除的文件)git add [dir] 添加指定目录到暂存区，包括子目录 git add . 添加当前目录的所有文件到暂存区(表示添加新文件和编辑过的文件不包括删除的文件)git add -u 表示添加编辑或者删除的文件，不包括新添加的文件 git rm [filename] 删除工作区文件并放进暂存区如果想从暂存区撤销：git reset HEAD -- [filename]如果想撤销工作区的修改：git checkout -- [filename]注意区别 : rm [filename] 删除工作区文件, 并没有放进暂存区如果想撤销工作区的修改：git checkout -- [filename]git rm --cached [filename] 停止追踪文件，但该文件会保留在工作区(untracked状态) 代码提交 12345678git commit -m [message] 暂存区提交到仓库区git commit [filename1] [filename2] ... -m [message] 暂存区的指定文件提交到仓库区git commit -a -m [message] 工作区中修改后，还未使用git add . 命令添加到暂存区中的文件也一并提交上去 相当于git add . 与git commit –m [message] 两句操作合并为一句进行使用。commit完成过后，git status,下方的工作区是干净的git commit -v 提交时显示所有diff信息 分支 12345678910111213141516171819git branch 列出所有本地分支git branch -r 列出所有远程分支git branch -a 列出所有本地分支和远程分支git branch [branch-name] 新建一个分支，但依然停留在当前分支git checkout -b [branch] 新建一个分支，并切换到该分支git branch --track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系git checkout [branch-name] 切换到指定分支，并更新工作区git branch --set-upstream [branch] [remote-branch] 建立追踪关系，在现有分支与指定的远程分支之间git merge [branch] 合并指定分支到当前分支 git branch -d [branch-name] 删除分支 标签 1234567891011121314151617git tag 列出所有taggit tag [tag] 新建一个tag在当前commitgit tag [tag] [commit] 新建一个tag在指定commitgit tag -d [tag] 删除本地taggit push origin :refs/tags/[tagName] 删除远程taggit show [tag] 查看tag信息git push [remote] [tag] 提交指定taggit push [remote] --tags 提交所有taggit checkout -b [branch] [tag] 新建一个分支，指向某个tag 查看信息 12345678910111213141516171819git status 显示有变更的文件git log 显示当前分支的版本历史git log --stat 显示commit历史，以及每次commit发生变更的文件git log -p [file] 显示指定文件相关的每一次diff‘git log -5 --pretty --oneline 显示过去5次提交git shortlog -sn 显示所有提交过的用户，按提交次数排序git blame [file] 显示指定文件是什么人在什么时间修改过git diff 显示暂存区和工作区的差异git diff --cached [file] 显示工作区与当前分支最新commit之间的差异git reflog 显示当前分支的最近几次提交 远程同步 123456789101112131415git fetch [remote] 下载远程仓库的所有变动git remote -v 显示所有远程仓库 git remote show [remote] 显示某个远程仓库的信息git remote add [shortname] [url] 增加一个新的远程仓库，并命名git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并git push [remote] [branch] 上传本地指定分支到远程仓库git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突git push [remote] --all 推送所有分支到远程仓库 撤销 1234567891011121314151617181920git checkout [file] 恢复暂存区的指定文件到工作区git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区git checkout . 恢复暂存区的所有文件到工作区git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset --hard 重置暂存区与工作区，与上一次commit保持一致git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset --hard [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --keep [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变git revert [commit] 新建一个commit，用来撤销指定commit,后者的所有变化都将被前者抵消，并且应用到当前分支git stashgit stash pop 暂时将未提交的变化移除，稍后再移入]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyhton中内建函数]]></title>
    <url>%2Fposts%2F6610edc8.html</url>
    <content type="text"><![CDATA[内建函数 hasattrhasattr()函数用于判断对象是否包含对应的属性，返回False/True hasattr(object, name)object –对象name – 字符串，属性名]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019书单]]></title>
    <url>%2Fposts%2F8c42af6d.html</url>
    <content type="text"><![CDATA[2019年书单 图解HTTP 大秦帝国 最近看完科幻小说，突然想看点有关于历史的书，被安利的好久的大秦帝国被我下到了kindle里，大秦帝国这本书太厚了，可能好久都看不完….]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[元旦快乐！]]></title>
    <url>%2Fposts%2F66b768da.html</url>
    <content type="text"><![CDATA[元旦快乐！ 最近懒得都没写2018的总结。 希望在2019年：坚持做到每个月的阅读量比上一个月的高。不要等到书到用时方恨少！读书，可以让你遇到更好的人，见到更精彩的世界，让自己拥有更好更多的选择。不要等到年纪大了才遗憾：是年轻时读书太少！多读书，读好书，好读书，趁现在还来得及。最后要时常打电话给家人。]]></content>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2F16ac1d86.html</url>
    <content type="text"><![CDATA[最近电脑做了双系统，win+Ubuntu。沉迷于Ubuntu的环境，感觉Ubuntu的操作界面很高效、简洁。然后就是最近上午校内实习，下午就忙着看机器学习。可能好久都不会来win上面更新了….等什么时候有心情了，有什么想说的了，在来倾诉一番吧。]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决Ubuntu终端中的Vi不听话]]></title>
    <url>%2Fposts%2Fa5ead307.html</url>
    <content type="text"><![CDATA[在装好Ubuntu后，使用Vi来修改文件时，发现好像不太对劲.在编辑模式下，我的方向键都不会移动方向，反而变成输出字母ABCD。然后Backspace（退格键）也无法删除编辑错误的东西，只能使用Delete键来删除。这次我觉得不再是版本的问题了，于是上网找了找。 解决方案用root权限来编辑/etc/vim/vimrc.tiny文件。做如下修改：12set compatible -&gt; set nocompatiblesetbackspace=2]]></content>
  </entry>
  <entry>
    <title><![CDATA[双十一]]></title>
    <url>%2Fposts%2F6650375a.html</url>
    <content type="text"><![CDATA[汪汪汪！]]></content>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立冬]]></title>
    <url>%2Fposts%2F50f733a7.html</url>
    <content type="text"><![CDATA[立冬了。立冬补冬，补嘴空。 二餐的人太多，就没能吃上饺子，想吃玉米肉的！馋…]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2F82a02628.html</url>
    <content type="text"><![CDATA[为什么在想学习的时候就会有其他的事情发生？ &#160; &#160; &#160; &#160;想着在周末的时候看看视频学学习，就被老师叫去实验室帮忙。&#160; &#160; &#160; &#160;想着下午学习看书，一定会有其他的事情来打扰你。&#160; &#160; &#160; &#160;所以我觉得学习的黄金时间就是深夜。当人们都睡着了、没有一丝嘈杂的声音，正是我们开始学习的最佳时刻。我记得作家巴尔扎克的写作时间是凌晨一点到五点，休息片刻写到八点左右，每天用五十杯咖啡来刺激写作，白天的时间用来睡觉和接待客人。路遥也是早晨从中午开始，每天晚上陪他的是两只老鼠。晚上的时间是他们效率最高的时候。而程序员靠的不是晚上的灵光乍现，是因为白天的碌碌无为而产生的愧疚感。&#160; &#160; &#160; &#160;好啦，今天就这样啦，洗洗睡。睡醒过后，明天又是正能量满满的一天。&#160; &#160; &#160; &#160;晚安！]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2F6cae4704.html</url>
    <content type="text"><![CDATA[&#160; 为什么要自己制作一个博客呢？在微博上面，空间写写不好么？ 微博，空间固然很方便，但是也太low了。满足不了自己的这颗臭牛逼的心，结合自己的专业，决定动手搭建个人博客才符合自己的胃口。&#160; &#160; &#160; &#160;首先说说一开始的坑，最开始一块钱在腾讯云上面注册个域名，后来在知乎上面都说阿里云的服务器主机比较好，在阿里云买了一个月的学生机，发现没有备案码，需要买三个月以上才能备案，得，买！！！，续费两个月，才发现腾讯的域名只能用腾讯的主机。gg。又回归阿里注册个域名。申请备案，身份证照片、网站真实性检验单都打印了，最后发现需要注册人手机号的三个月的消费账单，还必须是实名本人的，手上三个手机号，没有一个是自己实名的。在纠结犹豫着要不要周末回家备个案的时候，浏览到腾讯云备案没那么苛刻，不需要消费账单，兜兜转转还是你腾讯云。很快提交了各种资料，客服下午就打来电话，要求改一下不符合的地方。 现在坐等幕布，然后拍照到管局审核。&#160; &#160; &#160; &#160;在等幕布的时候发现制作个人博客不需要主机备案，在github上托管仓库，用hexo在本地制作就可以了，甚至域名解析都不用。看到这里我哭了。手里抓着钱包心痛。&#160; &#160; &#160; &#160;最后觉得时间过得太快了，一眨眼我都大三了，觉得什么都没学到，看的python也看一章忘一章，觉得时间留不住，还是记录在纸上才能留存下去。我想让时间慢下来，每个假期哪儿也不去，看窗外的四季变化，在窗子里思念过去，把文字排列整齐。]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[摘录]]></title>
    <url>%2Fposts%2F9b6a3ba2.html</url>
    <content type="text"><![CDATA[我眼中的世界非黑即白，而你是色彩，是我人生中的全部色彩。那即将缠绕他一生的笑声，每次都像有什么东西光着脚丫在他的胸膛内奔跑从没听过如此动人的声音 她说话的样子就像随时都会笑出声来 而她笑出声的时候 欧维觉得那笑声像是香槟泡沫发出的声音要是有人问起，他会说，在她之前，他没有生活。之后也没有。对于死亡最大的恐惧，在于它与我们擦肩而过，留下我们独自一人 《一个叫欧维的男人决定去死》]]></content>
      <categories>
        <category>摘录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如你所愿]]></title>
    <url>%2Fposts%2Fff3f73a2.html</url>
    <content type="text"><![CDATA[生而为人，我很抱歉 &#160; &#160; &#160; &#160;今天看完了被嫌弃的松子的一生，首先要自爱 才能值得别人去爱你，其实很羡慕松子，松子能够在人生的每一个阶段每一个抉择的时候都能够按照内心的指示去选择，哪怕是这个选择是众人所弃之，所不齿的，松子都能够很好的选择，反观我们，犹犹豫豫，慌慌张张，连一个晚上去洗脸都要拉上一个室友去。如此一比，顿时感觉我们却少的是忍受孤独的能力。&#160; &#160; &#160; &#160;文中有这样一个片段，松子在失手杀掉小野寺，在监狱考取理发师的资格，出狱后本应该在 茜 店里面安稳，踏实的去过普通的生活，没想到遇见了初中时的学生 龙洋一，龙洋一对松子表明了自己的爱意，不嫌弃松子之前有杀过人，和小白脸同居过，当过土耳其女郎，以及和作家的厮混，这些的这些他都不介意。读到这时的我本以为松子就会和龙洋一这样渡过一生，不在困难。没想到龙洋一的身份并不是简单的司机，而是运贩毒品的小弟，同时也是一个不单纯的警察卧底，在他提出想放弃这样混沌的生活，警察以及社团都没有放过他，社团大哥知道龙洋一和松子躲在的旅店，给了他24小时的时间，让他最后享受一回，时间一到，要么大哥杀进去，要么给龙洋一自杀的机会，这也是大哥最后的仁慈。旅店内 他们凭着冰毒的劲头，疯狂的做爱，说着情话，幻想着未来，在最后的时刻，龙洋一拨通了报警电话，留住了自己一命，同时因为吸毒贩毒、龙洋一处以四年的刑期，松子被判了一年，在松子出狱的时候，她傻傻的希望和龙洋一结婚，并对龙洋一寄去了结婚申请书，这时的龙洋一突然觉得自己配不上松子，觉得这么多年来都是他害得松子这样，没有签申请书。而松子以为这只是龙洋一 一时小孩子脾气犯了 松子在监狱附近找了一家理发店工作，每天上班骑车的路上能路过监狱的围墙，她会自言自语也是对着围墙里面的龙洋一说话，自己叨扰着 要加油啊！龙洋一 今天天气不错呢 你还好吗…… 松子每天很努力的工作，每天的目标都定在了三年后他出狱的时候，每天重复着，上班，对着围墙讲话，工作，下班回家，重复前一天，生活很有动力。三年一晃而过，今天就是龙洋一出狱的时候了，她早早的起床，闷了饭，煮了汤，做了他最爱吃的菜，并想到等一起回到家后再炒鸡蛋，换上了准备了好久的内衣，外套。远远的站在监狱大门外等候着，咔嗒大门开了，龙洋一瞪大了双眼，惊奇的看着她，松子小跑上去想抱住他，却被他一把推开了，他本以为松子这么多年应该忘记了他，他抢走了松子的钱，跑开了，留下松子站在原地喊着，龙洋一那边不是回家的方向啊，我在这里。&#160; &#160; &#160; &#160;读到这里我再也忍受不住，眼泪不禁的往外流，心酸，那时的我就好像站在了松子的身后，看着龙洋一跑开，心中的苦涩，一瞬间慌了神三年的目标，就在这一瞬间瓦解。&#160; &#160; &#160; &#160;对不起，生而为人，我很抱歉。&#160; &#160; &#160; &#160;晚安。06.18-23:57]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>被嫌弃的松子的一生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随记]]></title>
    <url>%2Fposts%2Ff211d1c6.html</url>
    <content type="text"><![CDATA[&#160; &#160; &#160; &#160;最孤单的人分为两种，一种是恨不得全世界的都跟他一样倒霉，一种则希望别人能幸福，因为看到幸福的人，他也略略温暖。]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2Fposts%2Ff7d18982.html</url>
    <content type="text"><![CDATA[感谢你来到我的小站，这将是我记录生活的地方。记录是一件拯救生命的决定。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
